diff --git a/contrib/ivshmem-server/ivshmem-server.c b/contrib/ivshmem-server/ivshmem-server.c
index 2f3c7320a..603132731 100644
--- a/contrib/ivshmem-server/ivshmem-server.c
+++ b/contrib/ivshmem-server/ivshmem-server.c
@@ -11,6 +11,7 @@
 
 #include <sys/socket.h>
 #include <sys/un.h>
+#include <sys/mman.h>
 
 #include "ivshmem-server.h"
 
@@ -290,6 +291,7 @@ ivshmem_server_start(IvshmemServer *server)
 {
     struct sockaddr_un s_un;
     int shm_fd, sock_fd, ret;
+    void *ptr;
 
     /* open shm file */
     if (server->use_shm_open) {
@@ -297,11 +299,12 @@ ivshmem_server_start(IvshmemServer *server)
                              server->shm_path);
         shm_fd = shm_open(server->shm_path, O_CREAT | O_RDWR, S_IRWXU);
     } else {
-        gchar *filename = g_strdup_printf("%s/ivshmem.XXXXXX", server->shm_path);
+        gchar *filename = g_strdup_printf("%s/ivshmem", server->shm_path);
         IVSHMEM_SERVER_DEBUG(server, "Using file-backed shared memory: %s\n",
                              server->shm_path);
-        shm_fd = mkstemp(filename);
-        unlink(filename);
+        // shm_fd = mkstemp(filename);
+        shm_fd = open(filename, O_RDWR | O_CREAT, 0666);
+        // unlink(filename);
         g_free(filename);
     }
 
@@ -315,6 +318,9 @@ ivshmem_server_start(IvshmemServer *server)
                 strerror(errno));
         goto err_close_shm;
     }
+    ptr = mmap(0, server->shm_size, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_HUGETLB/*|MAP_LOCKED*/,
+            server->shm_fd, 0);
+    printf("mmap(): ptr = 0x%p\n", ptr);
 
     IVSHMEM_SERVER_DEBUG(server, "create & bind socket %s\n",
                          server->unix_sock_path);
diff --git a/docs/system/devices/ivshmem-flat.rst b/docs/system/devices/ivshmem-flat.rst
new file mode 100644
index 000000000..1f9705280
--- /dev/null
+++ b/docs/system/devices/ivshmem-flat.rst
@@ -0,0 +1,33 @@
+Inter-VM Shared Memory Flat Device
+----------------------------------
+
+The ivshmem-flat device is meant to be used on machines that lack a PCI bus,
+making them unsuitable for the use of the traditional ivshmem device modeled as
+a PCI device. Machines like those with a Cortex-M MCU are good candidates to use
+the ivshmem-flat device. Also, since the flat version maps the control and
+status registers directly to the memory, it requires a quite tiny "device
+driver" to interact with other VMs, which is useful in some RTOSes, like
+Zephyr, which usually run on constrained resource targets.
+
+Similar to the ivshmem device, the ivshmem-flat device supports both peer
+notification via HW interrupts and Inter-VM shared memory. This allows the
+device to be used together with the traditional ivshmem, enabling communication
+between, for instance, an aarch64 VM  (using the traditional ivshmem device and
+running Linux), and an arm VM (using the ivshmem-flat device and running Zephyr
+instead).
+
+The ivshmem-flat device does not support the use of a ``memdev`` option (see
+ivshmem.rst for more details). It relies on the ivshmem server to create and
+distribute the proper shared memory file descriptor and the eventfd(s) to notify
+(interrupt) the peers. Therefore, to use this device, it is always necessary to
+have an ivshmem server up and running for proper device creation.
+
+Although the ivshmem-flat supports both peer notification (interrupts) and
+shared memory, the interrupt mechanism is optional. If no input IRQ is
+specified for the device it is disabled, preventing the VM from notifying or
+being notified by other VMs (a warning will be displayed to the user to inform
+the IRQ mechanism is disabled). The shared memory region is always present.
+
+The MMRs (INTRMASK, INTRSTATUS, IVPOSITION, and DOORBELL registers) offsets at
+the MMR region, and their functions, follow the ivshmem spec, so they work
+exactly as in the ivshmem PCI device (see ./specs/ivshmem-spec.txt).
diff --git a/hw/core/sysbus.c b/hw/core/sysbus.c
index 35f902b58..44536f58b 100644
--- a/hw/core/sysbus.c
+++ b/hw/core/sysbus.c
@@ -148,9 +148,11 @@ static void sysbus_mmio_map_common(SysBusDevice *dev, int n, hwaddr addr,
                                             priority);
     }
     else {
+        printf("Before memory_region_add_subregion\n");
         memory_region_add_subregion(get_system_memory(),
                                     addr,
                                     dev->mmio[n].memory);
+        printf("After memory_region_add_subregion\n");
     }
 }
 
diff --git a/hw/i386/pc_q35.c b/hw/i386/pc_q35.c
index dc27a9e22..a760caebc 100644
--- a/hw/i386/pc_q35.c
+++ b/hw/i386/pc_q35.c
@@ -57,6 +57,7 @@
 #include "hw/hyperv/vmbus-bridge.h"
 #include "hw/mem/nvdimm.h"
 #include "hw/i386/acpi-build.h"
+#include "hw/misc/ivshmem.h"
 
 /* ICH9 AHCI has 6 ports */
 #define MAX_SATA_PORTS     6
@@ -377,6 +378,7 @@ static void pc_q35_machine_options(MachineClass *m)
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_INTEL_IOMMU_DEVICE);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_RAMFB_DEVICE);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_VMBUS_BRIDGE);
+    machine_class_allow_dynamic_sysbus_dev(m, TYPE_IVSHMEM_FLAT);
 }
 
 static void pc_q35_8_1_machine_options(MachineClass *m)
diff --git a/hw/misc/ivshmem.c b/hw/misc/ivshmem.c
index d66d91217..f68964442 100644
--- a/hw/misc/ivshmem.c
+++ b/hw/misc/ivshmem.c
@@ -36,6 +36,7 @@
 #include "chardev/char-fe.h"
 #include "sysemu/hostmem.h"
 #include "qapi/visitor.h"
+#include "hw/sysbus.h"
 
 #include "hw/misc/ivshmem.h"
 #include "qom/object.h"
@@ -59,6 +60,7 @@
 
 #define TYPE_IVSHMEM_COMMON "ivshmem-common"
 typedef struct IVShmemState IVShmemState;
+typedef struct IvshmemFTState IvshmemFTState;
 DECLARE_INSTANCE_CHECKER(IVShmemState, IVSHMEM_COMMON,
                          TYPE_IVSHMEM_COMMON)
 
@@ -74,6 +76,9 @@ DECLARE_INSTANCE_CHECKER(IVShmemState, IVSHMEM_DOORBELL,
 DECLARE_INSTANCE_CHECKER(IVShmemState, IVSHMEM,
                          TYPE_IVSHMEM)
 
+#define TYPE_IVSHMEM_FLAT "ivshmem-flat"
+DECLARE_INSTANCE_CHECKER(IvshmemFTState, IVSHMEM_FLAT, TYPE_IVSHMEM_FLAT)
+
 typedef struct Peer {
     int nb_eventfds;
     EventNotifier *eventfds;
@@ -117,6 +122,14 @@ struct IVShmemState {
     /* migration stuff */
     OnOffAuto master;
     Error *migration_blocker;
+
+    /* flat memory stuff */
+    DeviceState *flat_dev;
+    MemoryRegion flat_mem;
+};
+
+struct IvshmemFTState {
+    SysBusDevice parent_obj;
 };
 
 /* registers for the Inter-VM shared memory device */
@@ -479,6 +492,10 @@ static void process_msg_shmem(IVShmemState *s, int fd, Error **errp)
     Error *local_err = NULL;
     struct stat buf;
     size_t size;
+    void *ptr;
+    SysBusDevice *sbd;
+
+    printf("%s\n", __FUNCTION__);
 
     if (s->ivshmem_bar2) {
         error_setg(errp, "server sent unexpected shared memory message");
@@ -494,6 +511,12 @@ static void process_msg_shmem(IVShmemState *s, int fd, Error **errp)
     }
 
     size = buf.st_size;
+    close(fd);
+    fd = open("/dev/hugepages/ivshmem", O_RDWR | O_CREAT, 0666);
+    printf("Opened share file fd=%d\n", fd);
+    ptr = mmap(0, size, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_HUGETLB|MAP_LOCKED,
+            fd, 0);
+    printf("mmap(): 0x%p\n", ptr);
 
     /* mmap the region and map into the BAR2 */
     memory_region_init_ram_from_fd(&s->server_bar2, OBJECT(s), "ivshmem.bar2",
@@ -502,7 +525,24 @@ static void process_msg_shmem(IVShmemState *s, int fd, Error **errp)
         error_propagate(errp, local_err);
         return;
     }
+    printf("sysbus_create_simple\n");
+    s->flat_dev = sysbus_create_simple(TYPE_IVSHMEM_FLAT, -1, 0);
+    printf("s->flat_dev = %p\n", s->flat_dev);
 
+    memory_region_init_ram_ptr(&s->flat_mem, OBJECT(IVSHMEM_FLAT(s->flat_dev)), 
+                            "ivshmem.flat", size, ptr);
+
+    printf("SYS_BUS_DEVICE\n");
+    sbd = SYS_BUS_DEVICE(s->flat_dev);
+
+    printf("sysbus_init_mmio\n");
+    sysbus_init_mmio(sbd, &s->flat_mem);
+    printf("sbd->num_mmio=%d\n", sbd->num_mmio);
+
+    printf("sysbus_mmio_map\n");
+    sysbus_mmio_map(sbd, 0, 0x920000000);
+    printf("sysbus_mmio_map executed\n");
+ 
     s->ivshmem_bar2 = &s->server_bar2;
 }
 
@@ -1120,6 +1160,21 @@ static void ivshmem_doorbell_class_init(ObjectClass *klass, void *data)
     dc->vmsd = &ivshmem_doorbell_vmsd;
 }
 
+static Property ivshmem_flat_props[] = {
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void ivshmem_flat_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    dc->hotpluggable = true;
+    printf(">>>>>>>>>>>>>>>%s\n", __FUNCTION__);
+    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
+    device_class_set_props(dc, ivshmem_flat_props);
+    dc->user_creatable = false;
+}
+
 static const TypeInfo ivshmem_doorbell_info = {
     .name          = TYPE_IVSHMEM_DOORBELL,
     .parent        = TYPE_IVSHMEM_COMMON,
@@ -1128,11 +1183,19 @@ static const TypeInfo ivshmem_doorbell_info = {
     .class_init    = ivshmem_doorbell_class_init,
 };
 
+static const TypeInfo ivshmem_flat_info = {
+    .name = TYPE_IVSHMEM_FLAT,
+    .parent = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(IvshmemFTState),
+    .class_init = ivshmem_flat_class_init,
+};
+
 static void ivshmem_register_types(void)
 {
     type_register_static(&ivshmem_common_info);
     type_register_static(&ivshmem_plain_info);
     type_register_static(&ivshmem_doorbell_info);
+    type_register_static(&ivshmem_flat_info);
 }
 
 type_init(ivshmem_register_types)
diff --git a/include/hw/misc/ivshmem.h b/include/hw/misc/ivshmem.h
index 433ef53d7..43aeab73d 100644
--- a/include/hw/misc/ivshmem.h
+++ b/include/hw/misc/ivshmem.h
@@ -21,5 +21,6 @@
 #define IVSHMEM_H
 
 #define IVSHMEM_PROTOCOL_VERSION 0
+#define TYPE_IVSHMEM_FLAT "ivshmem-flat"
 
 #endif /* IVSHMEM_H */
diff --git a/util/mmap-alloc.c b/util/mmap-alloc.c
index ed14f9c64..8f7dc4f34 100644
--- a/util/mmap-alloc.c
+++ b/util/mmap-alloc.c
@@ -181,6 +181,7 @@ static void *mmap_reserve(size_t size, int fd)
  * Activate memory in a reserved region from the given fd (if any), to make
  * it accessible.
  */
+unsigned int mmap_hugepages = 0;
 static void *mmap_activate(void *ptr, size_t size, int fd,
                            uint32_t qemu_map_flags, off_t map_offset)
 {
@@ -200,12 +201,21 @@ static void *mmap_activate(void *ptr, size_t size, int fd,
     flags |= fd == -1 ? MAP_ANONYMOUS : 0;
     flags |= shared ? MAP_SHARED : MAP_PRIVATE;
     flags |= noreserve ? MAP_NORESERVE : 0;
+    if (mmap_hugepages) {
+        mmap_hugepages = 0;
+        munmap(ptr, size);
+        ptr = NULL;
+        flags |= MAP_HUGETLB;
+        flags &= ~MAP_FIXED;
+    }
+    printf("mmap_activate: flags=0x%x\n", flags);
     if (shared && sync) {
         map_sync_flags = MAP_SYNC | MAP_SHARED_VALIDATE;
     }
 
     activated_ptr = mmap(ptr, size, prot, flags | map_sync_flags, fd,
                          map_offset);
+    printf("mmap_activate: activated_ptr1=0x%p\n", activated_ptr);
     if (activated_ptr == MAP_FAILED && map_sync_flags) {
         if (errno == ENOTSUP) {
             char *proc_link = g_strdup_printf("/proc/self/fd/%d", fd);
@@ -229,7 +239,9 @@ static void *mmap_activate(void *ptr, size_t size, int fd,
          * If mmap failed with MAP_SHARED_VALIDATE | MAP_SYNC, we will try
          * again without these flags to handle backwards compatibility.
          */
+        flags &= ~MAP_HUGETLB;
         activated_ptr = mmap(ptr, size, prot, flags, fd, map_offset);
+        printf("mmap_activate: activated_ptr1=0x%p\n", activated_ptr);
     }
     return activated_ptr;
 }
