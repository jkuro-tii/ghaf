diff -ruN qemu-8.1.3.orig/.codechecker/reports/compiler_info.json qemu-8.1.3/.codechecker/reports/compiler_info.json
--- qemu-8.1.3.orig/.codechecker/reports/compiler_info.json	1970-01-01 04:00:00.000000000 +0400
+++ qemu-8.1.3/.codechecker/reports/compiler_info.json	2024-03-19 15:08:33.870171043 +0400
@@ -0,0 +1 @@
+{}
\ No newline at end of file
diff -ruN qemu-8.1.3.orig/docs/system/devices/ivshmem-flat.rst qemu-8.1.3/docs/system/devices/ivshmem-flat.rst
--- qemu-8.1.3.orig/docs/system/devices/ivshmem-flat.rst	1970-01-01 04:00:00.000000000 +0400
+++ qemu-8.1.3/docs/system/devices/ivshmem-flat.rst	2024-03-11 12:03:10.508301941 +0400
@@ -0,0 +1,33 @@
+Inter-VM Shared Memory Flat Device
+----------------------------------
+
+The ivshmem-flat device is meant to be used on machines that lack a PCI bus,
+making them unsuitable for the use of the traditional ivshmem device modeled as
+a PCI device. Machines like those with a Cortex-M MCU are good candidates to use
+the ivshmem-flat device. Also, since the flat version maps the control and
+status registers directly to the memory, it requires a quite tiny "device
+driver" to interact with other VMs, which is useful in some RTOSes, like
+Zephyr, which usually run on constrained resource targets.
+
+Similar to the ivshmem device, the ivshmem-flat device supports both peer
+notification via HW interrupts and Inter-VM shared memory. This allows the
+device to be used together with the traditional ivshmem, enabling communication
+between, for instance, an aarch64 VM  (using the traditional ivshmem device and
+running Linux), and an arm VM (using the ivshmem-flat device and running Zephyr
+instead).
+
+The ivshmem-flat device does not support the use of a ``memdev`` option (see
+ivshmem.rst for more details). It relies on the ivshmem server to create and
+distribute the proper shared memory file descriptor and the eventfd(s) to notify
+(interrupt) the peers. Therefore, to use this device, it is always necessary to
+have an ivshmem server up and running for proper device creation.
+
+Although the ivshmem-flat supports both peer notification (interrupts) and
+shared memory, the interrupt mechanism is optional. If no input IRQ is
+specified for the device it is disabled, preventing the VM from notifying or
+being notified by other VMs (a warning will be displayed to the user to inform
+the IRQ mechanism is disabled). The shared memory region is always present.
+
+The MMRs (INTRMASK, INTRSTATUS, IVPOSITION, and DOORBELL registers) offsets at
+the MMR region, and their functions, follow the ivshmem spec, so they work
+exactly as in the ivshmem PCI device (see ./specs/ivshmem-spec.txt).
diff -ruN qemu-8.1.3.orig/GNUmakefile qemu-8.1.3/GNUmakefile
--- qemu-8.1.3.orig/GNUmakefile	1970-01-01 04:00:00.000000000 +0400
+++ qemu-8.1.3/GNUmakefile	2024-03-11 12:03:10.508301941 +0400
@@ -0,0 +1,20 @@
+# This file is auto-generated by configure to support in-source tree
+# 'make' command invocation
+
+ifeq ($(MAKECMDGOALS),)
+recurse: all
+endif
+
+.NOTPARALLEL: %
+%: force
+	@echo 'changing dir to build for $(MAKE) "$(MAKECMDGOALS)"...'
+	@$(MAKE) -C build -f Makefile $(MAKECMDGOALS)
+	@if test "$(MAKECMDGOALS)" = "distclean" && \
+	    test -e build/auto-created-by-configure ; \
+	then \
+	    rm -rf build GNUmakefile ; \
+	fi
+force: ;
+.PHONY: force
+GNUmakefile: ;
+
diff -ruN qemu-8.1.3.orig/hw/i386/pc_q35.c qemu-8.1.3/hw/i386/pc_q35.c
--- qemu-8.1.3.orig/hw/i386/pc_q35.c	2024-03-11 11:57:16.507516660 +0400
+++ qemu-8.1.3/hw/i386/pc_q35.c	2024-03-11 12:06:32.864316895 +0400
@@ -57,6 +57,8 @@
 #include "hw/hyperv/vmbus-bridge.h"
 #include "hw/mem/nvdimm.h"
 #include "hw/i386/acpi-build.h"
+#include "hw/misc/ivshmem-flat.h"
+
 
 /* ICH9 AHCI has 6 ports */
 #define MAX_SATA_PORTS     6
@@ -377,6 +379,7 @@
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_INTEL_IOMMU_DEVICE);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_RAMFB_DEVICE);
     machine_class_allow_dynamic_sysbus_dev(m, TYPE_VMBUS_BRIDGE);
+    machine_class_allow_dynamic_sysbus_dev(m, TYPE_IVSHMEM_FLAT);
 }
 
 static void pc_q35_8_1_machine_options(MachineClass *m)
diff -ruN qemu-8.1.3.orig/hw/i386/pc_q35.c.orig qemu-8.1.3/hw/i386/pc_q35.c.orig
--- qemu-8.1.3.orig/hw/i386/pc_q35.c.orig	1970-01-01 04:00:00.000000000 +0400
+++ qemu-8.1.3/hw/i386/pc_q35.c.orig	2024-03-11 12:03:02.316260851 +0400
@@ -0,0 +1,683 @@
+/*
+ * Q35 chipset based pc system emulator
+ *
+ * Copyright (c) 2003-2004 Fabrice Bellard
+ * Copyright (c) 2009, 2010
+ *               Isaku Yamahata <yamahata at valinux co jp>
+ *               VA Linux Systems Japan K.K.
+ * Copyright (C) 2012 Jason Baron <jbaron@redhat.com>
+ *
+ * This is based on pc.c, but heavily modified.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/units.h"
+#include "hw/char/parallel-isa.h"
+#include "hw/loader.h"
+#include "hw/i2c/smbus_eeprom.h"
+#include "hw/rtc/mc146818rtc.h"
+#include "sysemu/kvm.h"
+#include "hw/kvm/clock.h"
+#include "hw/pci-host/q35.h"
+#include "hw/pci/pcie_port.h"
+#include "hw/qdev-properties.h"
+#include "hw/i386/x86.h"
+#include "hw/i386/pc.h"
+#include "hw/i386/amd_iommu.h"
+#include "hw/i386/intel_iommu.h"
+#include "hw/display/ramfb.h"
+#include "hw/firmware/smbios.h"
+#include "hw/ide/pci.h"
+#include "hw/ide/ahci.h"
+#include "hw/intc/ioapic.h"
+#include "hw/southbridge/ich9.h"
+#include "hw/usb.h"
+#include "hw/usb/hcd-uhci.h"
+#include "qapi/error.h"
+#include "qemu/error-report.h"
+#include "sysemu/numa.h"
+#include "hw/hyperv/vmbus-bridge.h"
+#include "hw/mem/nvdimm.h"
+#include "hw/i386/acpi-build.h"
+
+/* ICH9 AHCI has 6 ports */
+#define MAX_SATA_PORTS     6
+
+struct ehci_companions {
+    const char *name;
+    int func;
+    int port;
+};
+
+static const struct ehci_companions ich9_1d[] = {
+    { .name = TYPE_ICH9_USB_UHCI(1), .func = 0, .port = 0 },
+    { .name = TYPE_ICH9_USB_UHCI(2), .func = 1, .port = 2 },
+    { .name = TYPE_ICH9_USB_UHCI(3), .func = 2, .port = 4 },
+};
+
+static const struct ehci_companions ich9_1a[] = {
+    { .name = TYPE_ICH9_USB_UHCI(4), .func = 0, .port = 0 },
+    { .name = TYPE_ICH9_USB_UHCI(5), .func = 1, .port = 2 },
+    { .name = TYPE_ICH9_USB_UHCI(6), .func = 2, .port = 4 },
+};
+
+static int ehci_create_ich9_with_companions(PCIBus *bus, int slot)
+{
+    const struct ehci_companions *comp;
+    PCIDevice *ehci, *uhci;
+    BusState *usbbus;
+    const char *name;
+    int i;
+
+    switch (slot) {
+    case 0x1d:
+        name = "ich9-usb-ehci1";
+        comp = ich9_1d;
+        break;
+    case 0x1a:
+        name = "ich9-usb-ehci2";
+        comp = ich9_1a;
+        break;
+    default:
+        return -1;
+    }
+
+    ehci = pci_new_multifunction(PCI_DEVFN(slot, 7), name);
+    pci_realize_and_unref(ehci, bus, &error_fatal);
+    usbbus = QLIST_FIRST(&ehci->qdev.child_bus);
+
+    for (i = 0; i < 3; i++) {
+        uhci = pci_new_multifunction(PCI_DEVFN(slot, comp[i].func),
+                                     comp[i].name);
+        qdev_prop_set_string(&uhci->qdev, "masterbus", usbbus->name);
+        qdev_prop_set_uint32(&uhci->qdev, "firstport", comp[i].port);
+        pci_realize_and_unref(uhci, bus, &error_fatal);
+    }
+    return 0;
+}
+
+/* PC hardware initialisation */
+static void pc_q35_init(MachineState *machine)
+{
+    PCMachineState *pcms = PC_MACHINE(machine);
+    PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(pcms);
+    X86MachineState *x86ms = X86_MACHINE(machine);
+    Object *phb;
+    PCIBus *host_bus;
+    PCIDevice *lpc;
+    DeviceState *lpc_dev;
+    BusState *idebus[MAX_SATA_PORTS];
+    ISADevice *rtc_state;
+    MemoryRegion *system_memory = get_system_memory();
+    MemoryRegion *system_io = get_system_io();
+    MemoryRegion *pci_memory;
+    MemoryRegion *rom_memory;
+    GSIState *gsi_state;
+    ISABus *isa_bus;
+    int i;
+    PCIDevice *ahci;
+    ram_addr_t lowmem;
+    DriveInfo *hd[MAX_SATA_PORTS];
+    MachineClass *mc = MACHINE_GET_CLASS(machine);
+    bool acpi_pcihp;
+    bool keep_pci_slot_hpc;
+    uint64_t pci_hole64_size = 0;
+
+    /* Check whether RAM fits below 4G (leaving 1/2 GByte for IO memory
+     * and 256 Mbytes for PCI Express Enhanced Configuration Access Mapping
+     * also known as MMCFG).
+     * If it doesn't, we need to split it in chunks below and above 4G.
+     * In any case, try to make sure that guest addresses aligned at
+     * 1G boundaries get mapped to host addresses aligned at 1G boundaries.
+     */
+    if (machine->ram_size >= 0xb0000000) {
+        lowmem = 0x80000000;
+    } else {
+        lowmem = 0xb0000000;
+    }
+
+    /* Handle the machine opt max-ram-below-4g.  It is basically doing
+     * min(qemu limit, user limit).
+     */
+    if (!pcms->max_ram_below_4g) {
+        pcms->max_ram_below_4g = 4 * GiB;
+    }
+    if (lowmem > pcms->max_ram_below_4g) {
+        lowmem = pcms->max_ram_below_4g;
+        if (machine->ram_size - lowmem > lowmem &&
+            lowmem & (1 * GiB - 1)) {
+            warn_report("There is possibly poor performance as the ram size "
+                        " (0x%" PRIx64 ") is more then twice the size of"
+                        " max-ram-below-4g (%"PRIu64") and"
+                        " max-ram-below-4g is not a multiple of 1G.",
+                        (uint64_t)machine->ram_size, pcms->max_ram_below_4g);
+        }
+    }
+
+    if (machine->ram_size >= lowmem) {
+        x86ms->above_4g_mem_size = machine->ram_size - lowmem;
+        x86ms->below_4g_mem_size = lowmem;
+    } else {
+        x86ms->above_4g_mem_size = 0;
+        x86ms->below_4g_mem_size = machine->ram_size;
+    }
+
+    pc_machine_init_sgx_epc(pcms);
+    x86_cpus_init(x86ms, pcmc->default_cpu_version);
+
+    kvmclock_create(pcmc->kvmclock_create_always);
+
+    /* pci enabled */
+    if (pcmc->pci_enabled) {
+        pci_memory = g_new(MemoryRegion, 1);
+        memory_region_init(pci_memory, NULL, "pci", UINT64_MAX);
+        rom_memory = pci_memory;
+    } else {
+        pci_memory = NULL;
+        rom_memory = system_memory;
+    }
+
+    pc_guest_info_init(pcms);
+
+    if (pcmc->smbios_defaults) {
+        /* These values are guest ABI, do not change */
+        smbios_set_defaults("QEMU", mc->desc,
+                            mc->name, pcmc->smbios_legacy_mode,
+                            pcmc->smbios_uuid_encoded,
+                            pcms->smbios_entry_point_type);
+    }
+
+    /* create pci host bus */
+    phb = OBJECT(qdev_new(TYPE_Q35_HOST_DEVICE));
+
+    if (pcmc->pci_enabled) {
+        pci_hole64_size = object_property_get_uint(phb,
+                                                   PCI_HOST_PROP_PCI_HOLE64_SIZE,
+                                                   &error_abort);
+    }
+
+    /* allocate ram and load rom/bios */
+    pc_memory_init(pcms, system_memory, rom_memory, pci_hole64_size);
+
+    object_property_add_child(OBJECT(machine), "q35", phb);
+    object_property_set_link(phb, PCI_HOST_PROP_RAM_MEM,
+                             OBJECT(machine->ram), NULL);
+    object_property_set_link(phb, PCI_HOST_PROP_PCI_MEM,
+                             OBJECT(pci_memory), NULL);
+    object_property_set_link(phb, PCI_HOST_PROP_SYSTEM_MEM,
+                             OBJECT(system_memory), NULL);
+    object_property_set_link(phb, PCI_HOST_PROP_IO_MEM,
+                             OBJECT(system_io), NULL);
+    object_property_set_int(phb, PCI_HOST_BELOW_4G_MEM_SIZE,
+                            x86ms->below_4g_mem_size, NULL);
+    object_property_set_int(phb, PCI_HOST_ABOVE_4G_MEM_SIZE,
+                            x86ms->above_4g_mem_size, NULL);
+    object_property_set_bool(phb, PCI_HOST_BYPASS_IOMMU,
+                             pcms->default_bus_bypass_iommu, NULL);
+    sysbus_realize_and_unref(SYS_BUS_DEVICE(phb), &error_fatal);
+
+    /* pci */
+    host_bus = PCI_BUS(qdev_get_child_bus(DEVICE(phb), "pcie.0"));
+    pcms->bus = host_bus;
+
+    /* create ISA bus */
+    lpc = pci_new_multifunction(PCI_DEVFN(ICH9_LPC_DEV, ICH9_LPC_FUNC),
+                                TYPE_ICH9_LPC_DEVICE);
+    qdev_prop_set_bit(DEVICE(lpc), "smm-enabled",
+                      x86_machine_is_smm_enabled(x86ms));
+    pci_realize_and_unref(lpc, host_bus, &error_fatal);
+
+    rtc_state = ISA_DEVICE(object_resolve_path_component(OBJECT(lpc), "rtc"));
+
+    object_property_add_link(OBJECT(machine), PC_MACHINE_ACPI_DEVICE_PROP,
+                             TYPE_HOTPLUG_HANDLER,
+                             (Object **)&x86ms->acpi_dev,
+                             object_property_allow_set_link,
+                             OBJ_PROP_LINK_STRONG);
+    object_property_set_link(OBJECT(machine), PC_MACHINE_ACPI_DEVICE_PROP,
+                             OBJECT(lpc), &error_abort);
+
+    acpi_pcihp = object_property_get_bool(OBJECT(lpc),
+                                          ACPI_PM_PROP_ACPI_PCIHP_BRIDGE,
+                                          NULL);
+
+    keep_pci_slot_hpc = object_property_get_bool(OBJECT(lpc),
+                                                 "x-keep-pci-slot-hpc",
+                                                 NULL);
+
+    if (!keep_pci_slot_hpc && acpi_pcihp) {
+        object_register_sugar_prop(TYPE_PCIE_SLOT,
+                                   "x-do-not-expose-native-hotplug-cap",
+                                   "true", true);
+    }
+
+    /* irq lines */
+    gsi_state = pc_gsi_create(&x86ms->gsi, pcmc->pci_enabled);
+
+    lpc_dev = DEVICE(lpc);
+    for (i = 0; i < IOAPIC_NUM_PINS; i++) {
+        qdev_connect_gpio_out_named(lpc_dev, ICH9_GPIO_GSI, i, x86ms->gsi[i]);
+    }
+    isa_bus = ISA_BUS(qdev_get_child_bus(lpc_dev, "isa.0"));
+
+    if (x86ms->pic == ON_OFF_AUTO_ON || x86ms->pic == ON_OFF_AUTO_AUTO) {
+        pc_i8259_create(isa_bus, gsi_state->i8259_irq);
+    }
+
+    if (pcmc->pci_enabled) {
+        ioapic_init_gsi(gsi_state, "q35");
+    }
+
+    if (tcg_enabled()) {
+        x86_register_ferr_irq(x86ms->gsi[13]);
+    }
+
+    assert(pcms->vmport != ON_OFF_AUTO__MAX);
+    if (pcms->vmport == ON_OFF_AUTO_AUTO) {
+        pcms->vmport = ON_OFF_AUTO_ON;
+    }
+
+    /* init basic PC hardware */
+    pc_basic_device_init(pcms, isa_bus, x86ms->gsi, rtc_state, !mc->no_floppy,
+                         0xff0104);
+
+    if (pcms->sata_enabled) {
+        /* ahci and SATA device, for q35 1 ahci controller is built-in */
+        ahci = pci_create_simple_multifunction(host_bus,
+                                               PCI_DEVFN(ICH9_SATA1_DEV,
+                                                         ICH9_SATA1_FUNC),
+                                               "ich9-ahci");
+        idebus[0] = qdev_get_child_bus(&ahci->qdev, "ide.0");
+        idebus[1] = qdev_get_child_bus(&ahci->qdev, "ide.1");
+        g_assert(MAX_SATA_PORTS == ahci_get_num_ports(ahci));
+        ide_drive_get(hd, ahci_get_num_ports(ahci));
+        ahci_ide_create_devs(ahci, hd);
+    } else {
+        idebus[0] = idebus[1] = NULL;
+    }
+
+    if (machine_usb(machine)) {
+        /* Should we create 6 UHCI according to ich9 spec? */
+        ehci_create_ich9_with_companions(host_bus, 0x1d);
+    }
+
+    if (pcms->smbus_enabled) {
+        PCIDevice *smb;
+
+        /* TODO: Populate SPD eeprom data.  */
+        smb = pci_create_simple_multifunction(host_bus,
+                                              PCI_DEVFN(ICH9_SMB_DEV,
+                                                        ICH9_SMB_FUNC),
+                                              TYPE_ICH9_SMB_DEVICE);
+        pcms->smbus = I2C_BUS(qdev_get_child_bus(DEVICE(smb), "i2c"));
+
+        smbus_eeprom_init(pcms->smbus, 8, NULL, 0);
+    }
+
+    pc_cmos_init(pcms, idebus[0], idebus[1], rtc_state);
+
+    /* the rest devices to which pci devfn is automatically assigned */
+    pc_vga_init(isa_bus, host_bus);
+    pc_nic_init(pcmc, isa_bus, host_bus);
+
+    if (machine->nvdimms_state->is_enabled) {
+        nvdimm_init_acpi_state(machine->nvdimms_state, system_io,
+                               x86_nvdimm_acpi_dsmio,
+                               x86ms->fw_cfg, OBJECT(pcms));
+    }
+}
+
+#define DEFINE_Q35_MACHINE(suffix, name, compatfn, optionfn) \
+    static void pc_init_##suffix(MachineState *machine) \
+    { \
+        void (*compat)(MachineState *m) = (compatfn); \
+        if (compat) { \
+            compat(machine); \
+        } \
+        pc_q35_init(machine); \
+    } \
+    DEFINE_PC_MACHINE(suffix, name, pc_init_##suffix, optionfn)
+
+
+static void pc_q35_machine_options(MachineClass *m)
+{
+    PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
+    pcmc->pci_root_uid = 0;
+    pcmc->default_cpu_version = 1;
+
+    m->family = "pc_q35";
+    m->desc = "Standard PC (Q35 + ICH9, 2009)";
+    m->units_per_default_bus = 1;
+    m->default_machine_opts = "firmware=bios-256k.bin";
+    m->default_display = "std";
+    m->default_nic = "e1000e";
+    m->default_kernel_irqchip_split = false;
+    m->no_floppy = 1;
+    m->max_cpus = 1024;
+    m->no_parallel = !module_object_class_by_name(TYPE_ISA_PARALLEL);
+    machine_class_allow_dynamic_sysbus_dev(m, TYPE_AMD_IOMMU_DEVICE);
+    machine_class_allow_dynamic_sysbus_dev(m, TYPE_INTEL_IOMMU_DEVICE);
+    machine_class_allow_dynamic_sysbus_dev(m, TYPE_RAMFB_DEVICE);
+    machine_class_allow_dynamic_sysbus_dev(m, TYPE_VMBUS_BRIDGE);
+}
+
+static void pc_q35_8_1_machine_options(MachineClass *m)
+{
+    pc_q35_machine_options(m);
+    m->alias = "q35";
+}
+
+DEFINE_Q35_MACHINE(v8_1, "pc-q35-8.1", NULL,
+                   pc_q35_8_1_machine_options);
+
+static void pc_q35_8_0_machine_options(MachineClass *m)
+{
+    PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
+
+    pc_q35_8_1_machine_options(m);
+    m->alias = NULL;
+    compat_props_add(m->compat_props, hw_compat_8_0, hw_compat_8_0_len);
+    compat_props_add(m->compat_props, pc_compat_8_0, pc_compat_8_0_len);
+
+    /* For pc-q35-8.0 and older, use SMBIOS 2.8 by default */
+    pcmc->default_smbios_ep_type = SMBIOS_ENTRY_POINT_TYPE_32;
+    m->max_cpus = 288;
+}
+
+DEFINE_Q35_MACHINE(v8_0, "pc-q35-8.0", NULL,
+                   pc_q35_8_0_machine_options);
+
+static void pc_q35_7_2_machine_options(MachineClass *m)
+{
+    pc_q35_8_0_machine_options(m);
+    compat_props_add(m->compat_props, hw_compat_7_2, hw_compat_7_2_len);
+    compat_props_add(m->compat_props, pc_compat_7_2, pc_compat_7_2_len);
+}
+
+DEFINE_Q35_MACHINE(v7_2, "pc-q35-7.2", NULL,
+                   pc_q35_7_2_machine_options);
+
+static void pc_q35_7_1_machine_options(MachineClass *m)
+{
+    pc_q35_7_2_machine_options(m);
+    compat_props_add(m->compat_props, hw_compat_7_1, hw_compat_7_1_len);
+    compat_props_add(m->compat_props, pc_compat_7_1, pc_compat_7_1_len);
+}
+
+DEFINE_Q35_MACHINE(v7_1, "pc-q35-7.1", NULL,
+                   pc_q35_7_1_machine_options);
+
+static void pc_q35_7_0_machine_options(MachineClass *m)
+{
+    PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
+    pc_q35_7_1_machine_options(m);
+    pcmc->enforce_amd_1tb_hole = false;
+    compat_props_add(m->compat_props, hw_compat_7_0, hw_compat_7_0_len);
+    compat_props_add(m->compat_props, pc_compat_7_0, pc_compat_7_0_len);
+}
+
+DEFINE_Q35_MACHINE(v7_0, "pc-q35-7.0", NULL,
+                   pc_q35_7_0_machine_options);
+
+static void pc_q35_6_2_machine_options(MachineClass *m)
+{
+    pc_q35_7_0_machine_options(m);
+    compat_props_add(m->compat_props, hw_compat_6_2, hw_compat_6_2_len);
+    compat_props_add(m->compat_props, pc_compat_6_2, pc_compat_6_2_len);
+}
+
+DEFINE_Q35_MACHINE(v6_2, "pc-q35-6.2", NULL,
+                   pc_q35_6_2_machine_options);
+
+static void pc_q35_6_1_machine_options(MachineClass *m)
+{
+    pc_q35_6_2_machine_options(m);
+    compat_props_add(m->compat_props, hw_compat_6_1, hw_compat_6_1_len);
+    compat_props_add(m->compat_props, pc_compat_6_1, pc_compat_6_1_len);
+    m->smp_props.prefer_sockets = true;
+}
+
+DEFINE_Q35_MACHINE(v6_1, "pc-q35-6.1", NULL,
+                   pc_q35_6_1_machine_options);
+
+static void pc_q35_6_0_machine_options(MachineClass *m)
+{
+    pc_q35_6_1_machine_options(m);
+    compat_props_add(m->compat_props, hw_compat_6_0, hw_compat_6_0_len);
+    compat_props_add(m->compat_props, pc_compat_6_0, pc_compat_6_0_len);
+}
+
+DEFINE_Q35_MACHINE(v6_0, "pc-q35-6.0", NULL,
+                   pc_q35_6_0_machine_options);
+
+static void pc_q35_5_2_machine_options(MachineClass *m)
+{
+    pc_q35_6_0_machine_options(m);
+    compat_props_add(m->compat_props, hw_compat_5_2, hw_compat_5_2_len);
+    compat_props_add(m->compat_props, pc_compat_5_2, pc_compat_5_2_len);
+}
+
+DEFINE_Q35_MACHINE(v5_2, "pc-q35-5.2", NULL,
+                   pc_q35_5_2_machine_options);
+
+static void pc_q35_5_1_machine_options(MachineClass *m)
+{
+    PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
+
+    pc_q35_5_2_machine_options(m);
+    compat_props_add(m->compat_props, hw_compat_5_1, hw_compat_5_1_len);
+    compat_props_add(m->compat_props, pc_compat_5_1, pc_compat_5_1_len);
+    pcmc->kvmclock_create_always = false;
+    pcmc->pci_root_uid = 1;
+}
+
+DEFINE_Q35_MACHINE(v5_1, "pc-q35-5.1", NULL,
+                   pc_q35_5_1_machine_options);
+
+static void pc_q35_5_0_machine_options(MachineClass *m)
+{
+    pc_q35_5_1_machine_options(m);
+    m->numa_mem_supported = true;
+    compat_props_add(m->compat_props, hw_compat_5_0, hw_compat_5_0_len);
+    compat_props_add(m->compat_props, pc_compat_5_0, pc_compat_5_0_len);
+    m->auto_enable_numa_with_memdev = false;
+}
+
+DEFINE_Q35_MACHINE(v5_0, "pc-q35-5.0", NULL,
+                   pc_q35_5_0_machine_options);
+
+static void pc_q35_4_2_machine_options(MachineClass *m)
+{
+    pc_q35_5_0_machine_options(m);
+    compat_props_add(m->compat_props, hw_compat_4_2, hw_compat_4_2_len);
+    compat_props_add(m->compat_props, pc_compat_4_2, pc_compat_4_2_len);
+}
+
+DEFINE_Q35_MACHINE(v4_2, "pc-q35-4.2", NULL,
+                   pc_q35_4_2_machine_options);
+
+static void pc_q35_4_1_machine_options(MachineClass *m)
+{
+    pc_q35_4_2_machine_options(m);
+    compat_props_add(m->compat_props, hw_compat_4_1, hw_compat_4_1_len);
+    compat_props_add(m->compat_props, pc_compat_4_1, pc_compat_4_1_len);
+}
+
+DEFINE_Q35_MACHINE(v4_1, "pc-q35-4.1", NULL,
+                   pc_q35_4_1_machine_options);
+
+static void pc_q35_4_0_1_machine_options(MachineClass *m)
+{
+    PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
+    pc_q35_4_1_machine_options(m);
+    pcmc->default_cpu_version = CPU_VERSION_LEGACY;
+    /*
+     * This is the default machine for the 4.0-stable branch. It is basically
+     * a 4.0 that doesn't use split irqchip by default. It MUST hence apply the
+     * 4.0 compat props.
+     */
+    compat_props_add(m->compat_props, hw_compat_4_0, hw_compat_4_0_len);
+    compat_props_add(m->compat_props, pc_compat_4_0, pc_compat_4_0_len);
+}
+
+DEFINE_Q35_MACHINE(v4_0_1, "pc-q35-4.0.1", NULL,
+                   pc_q35_4_0_1_machine_options);
+
+static void pc_q35_4_0_machine_options(MachineClass *m)
+{
+    pc_q35_4_0_1_machine_options(m);
+    m->default_kernel_irqchip_split = true;
+    /* Compat props are applied by the 4.0.1 machine */
+}
+
+DEFINE_Q35_MACHINE(v4_0, "pc-q35-4.0", NULL,
+                   pc_q35_4_0_machine_options);
+
+static void pc_q35_3_1_machine_options(MachineClass *m)
+{
+    PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
+
+    pc_q35_4_0_machine_options(m);
+    m->default_kernel_irqchip_split = false;
+    m->smbus_no_migration_support = true;
+    pcmc->pvh_enabled = false;
+    compat_props_add(m->compat_props, hw_compat_3_1, hw_compat_3_1_len);
+    compat_props_add(m->compat_props, pc_compat_3_1, pc_compat_3_1_len);
+}
+
+DEFINE_Q35_MACHINE(v3_1, "pc-q35-3.1", NULL,
+                   pc_q35_3_1_machine_options);
+
+static void pc_q35_3_0_machine_options(MachineClass *m)
+{
+    pc_q35_3_1_machine_options(m);
+    compat_props_add(m->compat_props, hw_compat_3_0, hw_compat_3_0_len);
+    compat_props_add(m->compat_props, pc_compat_3_0, pc_compat_3_0_len);
+}
+
+DEFINE_Q35_MACHINE(v3_0, "pc-q35-3.0", NULL,
+                    pc_q35_3_0_machine_options);
+
+static void pc_q35_2_12_machine_options(MachineClass *m)
+{
+    pc_q35_3_0_machine_options(m);
+    compat_props_add(m->compat_props, hw_compat_2_12, hw_compat_2_12_len);
+    compat_props_add(m->compat_props, pc_compat_2_12, pc_compat_2_12_len);
+}
+
+DEFINE_Q35_MACHINE(v2_12, "pc-q35-2.12", NULL,
+                   pc_q35_2_12_machine_options);
+
+static void pc_q35_2_11_machine_options(MachineClass *m)
+{
+    pc_q35_2_12_machine_options(m);
+    m->default_nic = "e1000";
+    compat_props_add(m->compat_props, hw_compat_2_11, hw_compat_2_11_len);
+    compat_props_add(m->compat_props, pc_compat_2_11, pc_compat_2_11_len);
+}
+
+DEFINE_Q35_MACHINE(v2_11, "pc-q35-2.11", NULL,
+                   pc_q35_2_11_machine_options);
+
+static void pc_q35_2_10_machine_options(MachineClass *m)
+{
+    pc_q35_2_11_machine_options(m);
+    compat_props_add(m->compat_props, hw_compat_2_10, hw_compat_2_10_len);
+    compat_props_add(m->compat_props, pc_compat_2_10, pc_compat_2_10_len);
+    m->auto_enable_numa_with_memhp = false;
+}
+
+DEFINE_Q35_MACHINE(v2_10, "pc-q35-2.10", NULL,
+                   pc_q35_2_10_machine_options);
+
+static void pc_q35_2_9_machine_options(MachineClass *m)
+{
+    pc_q35_2_10_machine_options(m);
+    compat_props_add(m->compat_props, hw_compat_2_9, hw_compat_2_9_len);
+    compat_props_add(m->compat_props, pc_compat_2_9, pc_compat_2_9_len);
+}
+
+DEFINE_Q35_MACHINE(v2_9, "pc-q35-2.9", NULL,
+                   pc_q35_2_9_machine_options);
+
+static void pc_q35_2_8_machine_options(MachineClass *m)
+{
+    pc_q35_2_9_machine_options(m);
+    compat_props_add(m->compat_props, hw_compat_2_8, hw_compat_2_8_len);
+    compat_props_add(m->compat_props, pc_compat_2_8, pc_compat_2_8_len);
+}
+
+DEFINE_Q35_MACHINE(v2_8, "pc-q35-2.8", NULL,
+                   pc_q35_2_8_machine_options);
+
+static void pc_q35_2_7_machine_options(MachineClass *m)
+{
+    pc_q35_2_8_machine_options(m);
+    m->max_cpus = 255;
+    compat_props_add(m->compat_props, hw_compat_2_7, hw_compat_2_7_len);
+    compat_props_add(m->compat_props, pc_compat_2_7, pc_compat_2_7_len);
+}
+
+DEFINE_Q35_MACHINE(v2_7, "pc-q35-2.7", NULL,
+                   pc_q35_2_7_machine_options);
+
+static void pc_q35_2_6_machine_options(MachineClass *m)
+{
+    X86MachineClass *x86mc = X86_MACHINE_CLASS(m);
+    PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
+
+    pc_q35_2_7_machine_options(m);
+    pcmc->legacy_cpu_hotplug = true;
+    x86mc->fwcfg_dma_enabled = false;
+    compat_props_add(m->compat_props, hw_compat_2_6, hw_compat_2_6_len);
+    compat_props_add(m->compat_props, pc_compat_2_6, pc_compat_2_6_len);
+}
+
+DEFINE_Q35_MACHINE(v2_6, "pc-q35-2.6", NULL,
+                   pc_q35_2_6_machine_options);
+
+static void pc_q35_2_5_machine_options(MachineClass *m)
+{
+    X86MachineClass *x86mc = X86_MACHINE_CLASS(m);
+
+    pc_q35_2_6_machine_options(m);
+    x86mc->save_tsc_khz = false;
+    m->legacy_fw_cfg_order = 1;
+    compat_props_add(m->compat_props, hw_compat_2_5, hw_compat_2_5_len);
+    compat_props_add(m->compat_props, pc_compat_2_5, pc_compat_2_5_len);
+}
+
+DEFINE_Q35_MACHINE(v2_5, "pc-q35-2.5", NULL,
+                   pc_q35_2_5_machine_options);
+
+static void pc_q35_2_4_machine_options(MachineClass *m)
+{
+    PCMachineClass *pcmc = PC_MACHINE_CLASS(m);
+
+    pc_q35_2_5_machine_options(m);
+    m->hw_version = "2.4.0";
+    pcmc->broken_reserved_end = true;
+    compat_props_add(m->compat_props, hw_compat_2_4, hw_compat_2_4_len);
+    compat_props_add(m->compat_props, pc_compat_2_4, pc_compat_2_4_len);
+}
+
+DEFINE_Q35_MACHINE(v2_4, "pc-q35-2.4", NULL,
+                   pc_q35_2_4_machine_options);
diff -ruN qemu-8.1.3.orig/hw/i386/pc_q35.c.rej qemu-8.1.3/hw/i386/pc_q35.c.rej
--- qemu-8.1.3.orig/hw/i386/pc_q35.c.rej	1970-01-01 04:00:00.000000000 +0400
+++ qemu-8.1.3/hw/i386/pc_q35.c.rej	2024-03-11 12:03:10.508301941 +0400
@@ -0,0 +1,11 @@
+--- hw/i386/pc_q35.c	2023-09-22 00:19:33.000000000 +0400
++++ hw/i386/pc_q35.c	2024-03-01 15:52:38.459892794 +0400
+@@ -372,6 +374,8 @@
+     machine_class_allow_dynamic_sysbus_dev(m, TYPE_INTEL_IOMMU_DEVICE);
+     machine_class_allow_dynamic_sysbus_dev(m, TYPE_RAMFB_DEVICE);
+     machine_class_allow_dynamic_sysbus_dev(m, TYPE_VMBUS_BRIDGE);
++    machine_class_allow_dynamic_sysbus_dev(m, TYPE_IVSHMEM_FLAT);
++
+     m->max_cpus = 288;
+ }
+ 
diff -ruN qemu-8.1.3.orig/hw/i386/x86.c qemu-8.1.3/hw/i386/x86.c
--- qemu-8.1.3.orig/hw/i386/x86.c	2024-03-11 11:57:16.507516660 +0400
+++ qemu-8.1.3/hw/i386/x86.c	2024-03-11 12:03:10.508301941 +0400
@@ -649,6 +649,7 @@
     d = SYS_BUS_DEVICE(dev);
     sysbus_realize_and_unref(d, &error_fatal);
     sysbus_mmio_map(d, 0, IO_APIC_DEFAULT_ADDRESS);
+    ivshmem_flat_create();
 
     for (i = 0; i < IOAPIC_NUM_PINS; i++) {
         gsi_state->ioapic_irq[i] = qdev_get_gpio_in(dev, i);
diff -ruN qemu-8.1.3.orig/hw/misc/ivshmem-flat.c qemu-8.1.3/hw/misc/ivshmem-flat.c
--- qemu-8.1.3.orig/hw/misc/ivshmem-flat.c	1970-01-01 04:00:00.000000000 +0400
+++ qemu-8.1.3/hw/misc/ivshmem-flat.c	2024-03-19 15:08:33.562169405 +0400
@@ -0,0 +1,507 @@
+/*
+ * Inter-VM Shared Memory Flat Device
+ *
+ * SPDX-FileCopyrightText: 2023 Linaro Ltd.
+ * SPDX-FileContributor: Gustavo Romero <gustavo.romero@linaro.org>
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ *
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/units.h"
+#include "qemu/error-report.h"
+#include "qemu/module.h"
+#include "qapi/error.h"
+#include "hw/irq.h"
+#include "hw/qdev-properties-system.h"
+#include "hw/sysbus.h"
+#include "chardev/char-fe.h"
+#include "exec/address-spaces.h"
+#include "trace.h"
+
+#include "hw/misc/ivshmem-flat.h"
+
+extern unsigned int mmap_hugepages;
+
+static int64_t ivshmem_flat_recv_msg(IvshmemFTState *s, int *pfd)
+{
+    int64_t msg;
+    int n, ret;
+
+    n = 0;
+    do {
+        ret = qemu_chr_fe_read_all(&s->server_chr, (uint8_t *)&msg + n,
+                                   sizeof(msg) - n);
+        if (ret < 0) {
+            if (ret == -EINTR) {
+                continue;
+            }
+            exit(1);
+        }
+        n += ret;
+    } while (n < sizeof(msg));
+
+    if (pfd) {
+        *pfd = qemu_chr_fe_get_msgfd(&s->server_chr);
+    }
+    return le64_to_cpu(msg);
+}
+
+static void ivshmem_flat_irq_handler(void *opaque)
+{
+    VectorInfo *vi = opaque;
+    EventNotifier *e = &vi->event_notifier;
+    uint16_t vector_id;
+    const VectorInfo (*v)[64];
+
+    assert(e->initialized);
+
+    vector_id = vi->id;
+
+    /*
+     * The vector info struct is passed to the handler via the 'opaque' pointer.
+     * This struct pointer allows the retrieval of the vector ID and its
+     * associated event notifier. However, for triggering an interrupt using
+     * qemu_set_irq, it's necessary to also have a pointer to the device state,
+     * i.e., a pointer to the IvshmemFTState struct. Since the vector info
+     * struct is contained within the IvshmemFTState struct, its pointer can be
+     * used to obtain the pointer to IvshmemFTState through simple pointer math.
+     */
+    v = (void *)(vi - vector_id); /* v =  &IvshmemPeer->vector[0] */
+    IvshmemPeer *own_peer = container_of(v, IvshmemPeer, vector);
+    IvshmemFTState *s = container_of(own_peer, IvshmemFTState, own);
+
+    /* Clear event  */
+    if (!event_notifier_test_and_clear(e)) {
+        return;
+    }
+
+    // trace_ivshmem_flat_irq_handler(vector_id);
+
+    /*
+     * Toggle device's output line, which is connected to interrupt controller,
+     * generating an interrupt request to the CPU.
+     */
+    qemu_set_irq(s->irq, true);
+    qemu_set_irq(s->irq, false);
+}
+
+static IvshmemPeer *ivshmem_flat_find_peer(IvshmemFTState *s, uint16_t peer_id)
+{
+    IvshmemPeer *peer;
+
+    /* Own ID */
+    if (s->own.id == peer_id) {
+        return &s->own;
+    }
+
+    /* Peer ID */
+    QTAILQ_FOREACH(peer, &s->peer, next) {
+        if (peer->id == peer_id) {
+            return peer;
+        }
+    }
+
+    return NULL;
+}
+
+static IvshmemPeer *ivshmem_flat_add_peer(IvshmemFTState *s, uint16_t peer_id)
+{
+    IvshmemPeer *new_peer;
+
+    new_peer = g_malloc0(sizeof(*new_peer));
+    new_peer->id = peer_id;
+    new_peer->vector_counter = 0;
+
+    QTAILQ_INSERT_TAIL(&s->peer, new_peer, next);
+
+    // trace_ivshmem_flat_new_peer(peer_id);
+
+    return new_peer;
+}
+
+static void ivshmem_flat_remove_peer(IvshmemFTState *s, uint16_t peer_id)
+{
+    IvshmemPeer *peer;
+
+    peer = ivshmem_flat_find_peer(s, peer_id);
+    assert(peer);
+
+    QTAILQ_REMOVE(&s->peer, peer, next);
+    for (int n = 0; n < peer->vector_counter; n++) {
+        int efd;
+        efd = event_notifier_get_fd(&(peer->vector[n].event_notifier));
+        close(efd);
+    }
+
+    g_free(peer);
+}
+
+static void ivshmem_flat_add_vector(IvshmemFTState *s, IvshmemPeer *peer,
+                                    int vector_fd)
+{
+    if (peer->vector_counter >= IVSHMEM_MAX_VECTOR_NUM) {
+        // trace_ivshmem_flat_add_vector_failure(peer->vector_counter,
+        //                                       vector_fd, peer->id);
+        close(vector_fd);
+
+        return;
+    }
+
+    // trace_ivshmem_flat_add_vector_success(peer->vector_counter,
+    //                                       vector_fd, peer->id);
+
+    /*
+     * Set vector ID and its associated eventfd notifier and add them to the
+     * peer.
+     */
+    peer->vector[peer->vector_counter].id = peer->vector_counter;
+    g_unix_set_fd_nonblocking(vector_fd, true, NULL);
+    event_notifier_init_fd(&peer->vector[peer->vector_counter].event_notifier,
+                           vector_fd);
+
+    /*
+     * If it's the device's own ID, register also the handler for the eventfd
+     * so the device can be notified by the other peers.
+     */
+    if (peer == &s->own) {
+        qemu_set_fd_handler(vector_fd, ivshmem_flat_irq_handler, NULL,
+                            &peer->vector);
+    }
+
+    peer->vector_counter++;
+}
+
+static void ivshmem_flat_process_msg(IvshmemFTState *s, uint64_t msg, int fd)
+{
+    uint16_t peer_id;
+    IvshmemPeer *peer;
+
+    peer_id = msg & 0xFFFF;
+    peer = ivshmem_flat_find_peer(s, peer_id);
+
+    if (!peer) {
+        peer = ivshmem_flat_add_peer(s, peer_id);
+    }
+
+    if (fd >= 0) {
+        ivshmem_flat_add_vector(s, peer, fd);
+    } else { /* fd == -1, which is received when peers disconnect. */
+        ivshmem_flat_remove_peer(s, peer_id);
+    }
+}
+
+static int ivshmem_flat_can_receive_data(void *opaque)
+{
+    IvshmemFTState *s = opaque;
+
+    assert(s->msg_buffered_bytes < sizeof(s->msg_buf));
+    return sizeof(s->msg_buf) - s->msg_buffered_bytes;
+}
+
+static void ivshmem_flat_read_msg(void *opaque, const uint8_t *buf, int size)
+{
+    IvshmemFTState *s = opaque;
+    int fd;
+    int64_t msg;
+
+    assert(size >= 0 && s->msg_buffered_bytes + size <= sizeof(s->msg_buf));
+    memcpy((unsigned char *)&s->msg_buf + s->msg_buffered_bytes, buf, size);
+    s->msg_buffered_bytes += size;
+    if (s->msg_buffered_bytes < sizeof(s->msg_buf)) {
+        return;
+    }
+    msg = le64_to_cpu(s->msg_buf);
+    s->msg_buffered_bytes = 0;
+
+    fd = qemu_chr_fe_get_msgfd(&s->server_chr);
+
+    ivshmem_flat_process_msg(s, msg, fd);
+}
+
+static uint64_t ivshmem_flat_iomem_read(void *opaque,
+                                        hwaddr offset, unsigned size)
+{
+    IvshmemFTState *s = opaque;
+    uint32_t ret;
+
+    // trace_ivshmem_flat_read_mmr(offset);
+
+    switch (offset) {
+    case INTMASK:
+        ret = 0; /* Ignore read since all bits are reserved in rev 1. */
+        break;
+    case INTSTATUS:
+        ret = 0; /* Ignore read since all bits are reserved in rev 1. */
+        break;
+    case IVPOSITION:
+        ret = s->own.id;
+        break;
+    case DOORBELL:
+        // trace_ivshmem_flat_read_mmr_doorbell(); /* DOORBELL is write-only */
+        ret = 0;
+        break;
+    default:
+        /* Should never reach out here due to iomem map range being exact */
+        // trace_ivshmem_flat_read_write_mmr_invalid(offset);
+        ret = 0;
+    }
+
+    return ret;
+}
+
+static int ivshmem_flat_interrupt_peer(IvshmemFTState *s,
+                                       uint16_t peer_id, uint16_t vector_id)
+{
+    IvshmemPeer *peer;
+
+    peer = ivshmem_flat_find_peer(s, peer_id);
+    if (!peer) {
+        // trace_ivshmem_flat_interrupt_invalid_peer(peer_id);
+        return 1;
+    }
+
+    event_notifier_set(&(peer->vector[vector_id].event_notifier));
+
+    return 0;
+}
+
+static void ivshmem_flat_iomem_write(void *opaque, hwaddr offset,
+                                     uint64_t value, unsigned size)
+{
+    IvshmemFTState *s = opaque;
+    uint16_t peer_id = (value >> 16) & 0xFFFF;
+    uint16_t vector_id = value & 0xFFFF;
+
+    // trace_ivshmem_flat_write_mmr(offset);
+
+    switch (offset) {
+    case INTMASK:
+        break;
+    case INTSTATUS:
+        break;
+    case IVPOSITION:
+        break;
+    case DOORBELL:
+        // trace_ivshmem_flat_interrupt_peer(peer_id, vector_id);
+        ivshmem_flat_interrupt_peer(s, peer_id, vector_id);
+        break;
+    default:
+        /* Should never reach out here due to iomem map range being exact. */
+        // trace_ivshmem_flat_read_write_mmr_invalid(offset);
+        break;
+    }
+
+    return;
+}
+
+static const MemoryRegionOps ivshmem_flat_ops = {
+    .read = ivshmem_flat_iomem_read,
+    .write = ivshmem_flat_iomem_write,
+    .endianness = DEVICE_LITTLE_ENDIAN,
+    .impl = { /* Read/write aligned at 32 bits. */
+        .min_access_size = 4,
+        .max_access_size = 4,
+    },
+};
+
+static void ivshmem_flat_instance_init(Object *obj)
+{
+    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
+    IvshmemFTState *s = IVSHMEM_FLAT(obj);
+
+    /*
+     * Init mem region for 4 MMRs (ivshmem_registers),
+     * 32 bits each => 16 bytes (0x10).
+     */
+    memory_region_init_io(&s->iomem, obj, &ivshmem_flat_ops, s,
+                          "ivshmem-mmio", 0x20);
+    printf("%s\n>>> s->iomem:%s addr=0x%lx size=0x%lx\n", memory_region_name(&s->iomem), __FUNCTION__,
+            memory_region_get_ram_addr(&s->iomem), memory_region_size(&s->iomem));
+
+    sysbus_init_mmio(sbd, &s->iomem);
+
+    printf(">>> s->iomem:%s addr=0x%lx size=0x%lx\n", memory_region_name(&s->iomem), memory_region_get_ram_addr(&s->iomem), 
+        memory_region_size(&s->iomem));
+
+    sysbus_mmio_map(sbd, 0, 0x1700000000);
+    printf(">>> s->iomem:%s addr=0x%lx size=0x%lx\n", memory_region_name(&s->iomem), memory_region_get_ram_addr(&s->iomem), 
+        memory_region_size(&s->iomem));
+
+    /*
+     * Create one output IRQ that will be connect to the
+     * machine's interrupt controller.
+     */
+    sysbus_init_irq(sbd, &s->irq);
+
+    QTAILQ_INIT(&s->peer);
+}
+
+static bool ivshmem_flat_connect_server(DeviceState *dev, Error **errp)
+{
+    IvshmemFTState *s = IVSHMEM_FLAT(dev);
+    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);
+    int64_t protocol_version, msg;
+    int shmem_fd;
+    uint16_t peer_id;
+    struct stat fdstat;
+    Error *local_err = NULL;
+#if 0
+    /* Check ivshmem server connection. */
+    if (!qemu_chr_fe_backend_connected(&s->server_chr)) {
+        error_setg(errp, "ivshmem server socket not specified or incorret."
+                         " Can't create device.");
+        return false;
+    }
+
+    /*
+     * Message sequence from server on new connection:
+     *  _____________________________________
+     * |STEP| uint64_t msg  | int fd         |
+     *  -------------------------------------
+     *
+     *  0    PROTOCOL        -1              \
+     *  1    OWN PEER ID     -1               |-- Header/Greeting
+     *  2    -1              shmem fd        /
+     *
+     *  3    PEER IDx        Other peer's Vector 0 eventfd
+     *  4    PEER IDx        Other peer's Vector 1 eventfd
+     *  .                    .
+     *  .                    .
+     *  .                    .
+     *  N    PEER IDy        Other peer's Vector 0 eventfd
+     *  N+1  PEER IDy        Other peer's Vector 1 eventfd
+     *  .                    .
+     *  .                    .
+     *  .                    .
+     *
+     *  ivshmem_flat_recv_msg() calls return 'msg' and 'fd'.
+     *
+     *  See ./docs/specs/ivshmem-spec.txt for details on the protocol.
+     */
+
+    /* Step 0 */
+    protocol_version = ivshmem_flat_recv_msg(s, NULL);
+
+    /* Step 1 */
+    msg = ivshmem_flat_recv_msg(s, NULL);
+    peer_id = 0xFFFF & msg;
+    s->own.id = peer_id;
+    s->own.vector_counter = 0;
+
+    // trace_ivshmem_flat_proto_ver_own_id(protocol_version, s->own.id);
+
+    /* Step 2 */
+    msg = ivshmem_flat_recv_msg(s, &shmem_fd);
+    /* Map shmem fd and MMRs into memory regions. */
+    if (msg != -1 || shmem_fd < 0) {
+        error_setg(errp, "Could not receive valid shmem fd."
+                         " Can't create device!");
+        return false;
+    }
+
+    if (fstat(shmem_fd, &fdstat) != 0) {
+        error_setg(errp, "Could not determine shmem fd size."
+                         " Can't create device!");
+        return false;
+    }
+    // trace_ivshmem_flat_shmem_size(shmem_fd, fdstat.st_size);
+
+    /*
+     * Shmem size provided by the ivshmem server must be equal to
+     * device's shmem size.
+     */
+    if (fdstat.st_size != s->shmem_size) {
+        error_setg(errp, "Can't map shmem fd: shmem size different"
+                         " from device size!");
+        return false;
+    }
+
+    /*
+     * Beyond step 2 ivshmem_process_msg, called by ivshmem_flat_read_msg
+     * handler -- when data is available on the server socket -- will handle
+     * the additional messages that will be generated by the server as peers
+     * connect or disconnect.
+     */
+    qemu_chr_fe_set_handlers(&s->server_chr, ivshmem_flat_can_receive_data,
+                             ivshmem_flat_read_msg, NULL, NULL, s, NULL, true);
+#endif
+    printf("%s memory_region_init_ram_from_fd fd=%d size=0x%x\n", __FUNCTION__, shmem_fd, s->shmem_size);
+    // memory_region_init_ram_from_fd(&s->shmem, OBJECT(s),
+    //                                "ivshmem-shmem", s->shmem_size,
+    //                                RAM_SHARED, shmem_fd, 0, &local_err);
+    mmap_hugepages = 0;
+    memory_region_init_ram_from_file(&s->shmem, OBJECT(s),
+                                   "ivshmem-shmem", s->shmem_size, 4096*0 + 2*1024*1024,
+                                   RAM_SHARED, "/dev/hugepages/ivshmem"/*"/dev/shm/ivshmem"*/, 0, false, &local_err);
+    if (local_err) {
+        error_propagate(errp, local_err);
+        return false;
+    }
+    printf(">>> name:%s addr=0x%lx size=0x%lx\n", memory_region_name(&s->shmem), memory_region_get_ram_addr(&s->shmem), 
+            memory_region_size(&s->shmem));
+    sysbus_init_mmio(sbd, &s->shmem);
+
+    sysbus_mmio_map(sbd, sbd->num_mmio-1, 0x920000000);
+
+    return true;
+}
+
+static void ivshmem_flat_realize(DeviceState *dev, Error **errp)
+{
+// qemu-kvm: ../hw/core/qdev.c:282: qdev_realize: Assertion `!dev->realized && !dev->parent_bus' failed.
+// Aborted (core dumped)
+    // sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &error_fatal);
+    // sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0x1300000000);
+    printf("%s\n", __FUNCTION__);
+    if (!ivshmem_flat_connect_server(dev, errp)) {
+        return;
+    }
+}
+
+static Property ivshmem_flat_props[] = {
+    DEFINE_PROP_CHR("chardev", IvshmemFTState, server_chr),
+    DEFINE_PROP_UINT32("shmem-size", IvshmemFTState, shmem_size, 16 * MiB),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void ivshmem_flat_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+
+    dc->hotpluggable = true;
+    dc->realize = ivshmem_flat_realize;
+
+    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
+    device_class_set_props(dc, ivshmem_flat_props);
+
+    /* Reason: Must be wired up in code (sysbus MRs and IRQ) */
+    dc->user_creatable = true;
+}
+
+static const TypeInfo ivshmem_flat_info = {
+    .name = TYPE_IVSHMEM_FLAT,
+    .parent = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(IvshmemFTState),
+    .instance_init = ivshmem_flat_instance_init,
+    .class_init = ivshmem_flat_class_init,
+};
+
+static void ivshmem_flat_register_types(void)
+{
+    type_register_static(&ivshmem_flat_info);
+}
+
+type_init(ivshmem_flat_register_types);
+
+void ivshmem_flat_create()
+{
+    DeviceState *dev = qdev_new(TYPE_IVSHMEM_FLAT);
+
+    printf("ivshmem_flat_create()\n");
+    // -> qemu-kvm: unable to map backing store for guest RAM: No such device
+
+    // sysbus_realize_and_unref(SYS_BUS_DEVICE(dev), &error_fatal);
+    // sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0x1300000000);
+
+}
\ No newline at end of file
diff -ruN qemu-8.1.3.orig/hw/misc/Kconfig qemu-8.1.3/hw/misc/Kconfig
--- qemu-8.1.3.orig/hw/misc/Kconfig	2024-03-11 11:57:16.502516635 +0400
+++ qemu-8.1.3/hw/misc/Kconfig	2024-03-11 12:03:10.508301941 +0400
@@ -63,6 +63,11 @@
     default y if PCI_DEVICES
     depends on PCI && LINUX && IVSHMEM && MSI_NONBROKEN
 
+config IVSHMEM_FLAT_DEVICE
+    bool
+    default y
+    depends on LINUX && IVSHMEM
+
 config ECCMEMCTL
     bool
     select ECC
diff -ruN qemu-8.1.3.orig/hw/misc/meson.build qemu-8.1.3/hw/misc/meson.build
--- qemu-8.1.3.orig/hw/misc/meson.build	2024-03-11 11:57:16.502516635 +0400
+++ qemu-8.1.3/hw/misc/meson.build	2024-03-11 12:08:47.911995791 +0400
@@ -37,6 +37,7 @@
 subdir('macio')
 
 system_ss.add(when: 'CONFIG_IVSHMEM_DEVICE', if_true: files('ivshmem.c'))
+system_ss.add(when: 'CONFIG_IVSHMEM_FLAT_DEVICE', if_true: files('ivshmem-flat.c'))
 
 system_ss.add(when: 'CONFIG_ALLWINNER_SRAMC', if_true: files('allwinner-sramc.c'))
 system_ss.add(when: 'CONFIG_ALLWINNER_A10_CCM', if_true: files('allwinner-a10-ccm.c'))
diff -ruN qemu-8.1.3.orig/hw/misc/meson.build.orig qemu-8.1.3/hw/misc/meson.build.orig
--- qemu-8.1.3.orig/hw/misc/meson.build.orig	1970-01-01 04:00:00.000000000 +0400
+++ qemu-8.1.3/hw/misc/meson.build.orig	2024-03-11 12:03:10.508301941 +0400
@@ -0,0 +1,147 @@
+system_ss.add(when: 'CONFIG_APPLESMC', if_true: files('applesmc.c'))
+system_ss.add(when: 'CONFIG_EDU', if_true: files('edu.c'))
+system_ss.add(when: 'CONFIG_FW_CFG_DMA', if_true: files('vmcoreinfo.c'))
+system_ss.add(when: 'CONFIG_ISA_DEBUG', if_true: files('debugexit.c'))
+system_ss.add(when: 'CONFIG_ISA_TESTDEV', if_true: files('pc-testdev.c'))
+system_ss.add(when: 'CONFIG_PCA9552', if_true: files('pca9552.c'))
+system_ss.add(when: 'CONFIG_PCI_TESTDEV', if_true: files('pci-testdev.c'))
+system_ss.add(when: 'CONFIG_UNIMP', if_true: files('unimp.c'))
+system_ss.add(when: 'CONFIG_EMPTY_SLOT', if_true: files('empty_slot.c'))
+system_ss.add(when: 'CONFIG_LED', if_true: files('led.c'))
+system_ss.add(when: 'CONFIG_PVPANIC_COMMON', if_true: files('pvpanic.c'))
+
+# ARM devices
+system_ss.add(when: 'CONFIG_PL310', if_true: files('arm_l2x0.c'))
+system_ss.add(when: 'CONFIG_INTEGRATOR_DEBUG', if_true: files('arm_integrator_debug.c'))
+system_ss.add(when: 'CONFIG_A9SCU', if_true: files('a9scu.c'))
+system_ss.add(when: 'CONFIG_ARM11SCU', if_true: files('arm11scu.c'))
+
+system_ss.add(when: 'CONFIG_ARM_V7M', if_true: files('armv7m_ras.c'))
+
+# Mac devices
+system_ss.add(when: 'CONFIG_MOS6522', if_true: files('mos6522.c'))
+
+# virt devices
+system_ss.add(when: 'CONFIG_VIRT_CTRL', if_true: files('virt_ctrl.c'))
+
+# RISC-V devices
+system_ss.add(when: 'CONFIG_MCHP_PFSOC_DMC', if_true: files('mchp_pfsoc_dmc.c'))
+system_ss.add(when: 'CONFIG_MCHP_PFSOC_IOSCB', if_true: files('mchp_pfsoc_ioscb.c'))
+system_ss.add(when: 'CONFIG_MCHP_PFSOC_SYSREG', if_true: files('mchp_pfsoc_sysreg.c'))
+system_ss.add(when: 'CONFIG_SIFIVE_TEST', if_true: files('sifive_test.c'))
+system_ss.add(when: 'CONFIG_SIFIVE_E_PRCI', if_true: files('sifive_e_prci.c'))
+system_ss.add(when: 'CONFIG_SIFIVE_E_AON', if_true: files('sifive_e_aon.c'))
+system_ss.add(when: 'CONFIG_SIFIVE_U_OTP', if_true: files('sifive_u_otp.c'))
+system_ss.add(when: 'CONFIG_SIFIVE_U_PRCI', if_true: files('sifive_u_prci.c'))
+
+subdir('macio')
+
+system_ss.add(when: 'CONFIG_IVSHMEM_DEVICE', if_true: files('ivshmem.c'))
+
+system_ss.add(when: 'CONFIG_ALLWINNER_SRAMC', if_true: files('allwinner-sramc.c'))
+system_ss.add(when: 'CONFIG_ALLWINNER_A10_CCM', if_true: files('allwinner-a10-ccm.c'))
+system_ss.add(when: 'CONFIG_ALLWINNER_A10_DRAMC', if_true: files('allwinner-a10-dramc.c'))
+system_ss.add(when: 'CONFIG_ALLWINNER_H3', if_true: files('allwinner-h3-ccu.c'))
+specific_ss.add(when: 'CONFIG_ALLWINNER_H3', if_true: files('allwinner-cpucfg.c'))
+system_ss.add(when: 'CONFIG_ALLWINNER_H3', if_true: files('allwinner-h3-dramc.c'))
+system_ss.add(when: 'CONFIG_ALLWINNER_H3', if_true: files('allwinner-h3-sysctrl.c'))
+system_ss.add(when: 'CONFIG_ALLWINNER_H3', if_true: files('allwinner-sid.c'))
+system_ss.add(when: 'CONFIG_ALLWINNER_R40', if_true: files('allwinner-r40-ccu.c'))
+system_ss.add(when: 'CONFIG_ALLWINNER_R40', if_true: files('allwinner-r40-dramc.c'))
+system_ss.add(when: 'CONFIG_AXP2XX_PMU', if_true: files('axp2xx.c'))
+system_ss.add(when: 'CONFIG_REALVIEW', if_true: files('arm_sysctl.c'))
+system_ss.add(when: 'CONFIG_NSERIES', if_true: files('cbus.c'))
+system_ss.add(when: 'CONFIG_ECCMEMCTL', if_true: files('eccmemctl.c'))
+system_ss.add(when: 'CONFIG_EXYNOS4', if_true: files('exynos4210_pmu.c', 'exynos4210_clk.c', 'exynos4210_rng.c'))
+system_ss.add(when: 'CONFIG_IMX', if_true: files(
+  'imx25_ccm.c',
+  'imx31_ccm.c',
+  'imx6_ccm.c',
+  'imx6_src.c',
+  'imx6ul_ccm.c',
+  'imx7_ccm.c',
+  'imx7_gpr.c',
+  'imx7_snvs.c',
+  'imx_ccm.c',
+  'imx_rngc.c',
+))
+system_ss.add(when: 'CONFIG_MAINSTONE', if_true: files('mst_fpga.c'))
+system_ss.add(when: 'CONFIG_NPCM7XX', if_true: files(
+  'npcm7xx_clk.c',
+  'npcm7xx_gcr.c',
+  'npcm7xx_mft.c',
+  'npcm7xx_pwm.c',
+  'npcm7xx_rng.c',
+))
+system_ss.add(when: 'CONFIG_OMAP', if_true: files(
+  'omap_clk.c',
+  'omap_gpmc.c',
+  'omap_l4.c',
+  'omap_sdrc.c',
+  'omap_tap.c',
+))
+system_ss.add(when: 'CONFIG_RASPI', if_true: files(
+  'bcm2835_mbox.c',
+  'bcm2835_mphi.c',
+  'bcm2835_property.c',
+  'bcm2835_rng.c',
+  'bcm2835_thermal.c',
+  'bcm2835_cprman.c',
+  'bcm2835_powermgt.c',
+))
+system_ss.add(when: 'CONFIG_SLAVIO', if_true: files('slavio_misc.c'))
+system_ss.add(when: 'CONFIG_ZYNQ', if_true: files('zynq_slcr.c'))
+system_ss.add(when: 'CONFIG_XLNX_ZYNQMP_ARM', if_true: files('xlnx-zynqmp-crf.c'))
+system_ss.add(when: 'CONFIG_XLNX_ZYNQMP_ARM', if_true: files('xlnx-zynqmp-apu-ctrl.c'))
+specific_ss.add(when: 'CONFIG_XLNX_VERSAL', if_true: files('xlnx-versal-crl.c'))
+system_ss.add(when: 'CONFIG_XLNX_VERSAL', if_true: files(
+  'xlnx-versal-xramc.c',
+  'xlnx-versal-pmc-iou-slcr.c',
+))
+system_ss.add(when: 'CONFIG_STM32F2XX_SYSCFG', if_true: files('stm32f2xx_syscfg.c'))
+system_ss.add(when: 'CONFIG_STM32F4XX_SYSCFG', if_true: files('stm32f4xx_syscfg.c'))
+system_ss.add(when: 'CONFIG_STM32F4XX_EXTI', if_true: files('stm32f4xx_exti.c'))
+system_ss.add(when: 'CONFIG_MPS2_FPGAIO', if_true: files('mps2-fpgaio.c'))
+system_ss.add(when: 'CONFIG_MPS2_SCC', if_true: files('mps2-scc.c'))
+
+system_ss.add(when: 'CONFIG_TZ_MPC', if_true: files('tz-mpc.c'))
+system_ss.add(when: 'CONFIG_TZ_MSC', if_true: files('tz-msc.c'))
+system_ss.add(when: 'CONFIG_TZ_PPC', if_true: files('tz-ppc.c'))
+system_ss.add(when: 'CONFIG_IOTKIT_SECCTL', if_true: files('iotkit-secctl.c'))
+system_ss.add(when: 'CONFIG_IOTKIT_SYSCTL', if_true: files('iotkit-sysctl.c'))
+system_ss.add(when: 'CONFIG_IOTKIT_SYSINFO', if_true: files('iotkit-sysinfo.c'))
+system_ss.add(when: 'CONFIG_ARMSSE_CPU_PWRCTRL', if_true: files('armsse-cpu-pwrctrl.c'))
+system_ss.add(when: 'CONFIG_ARMSSE_CPUID', if_true: files('armsse-cpuid.c'))
+system_ss.add(when: 'CONFIG_ARMSSE_MHU', if_true: files('armsse-mhu.c'))
+
+system_ss.add(when: 'CONFIG_PVPANIC_ISA', if_true: files('pvpanic-isa.c'))
+system_ss.add(when: 'CONFIG_PVPANIC_PCI', if_true: files('pvpanic-pci.c'))
+system_ss.add(when: 'CONFIG_AUX', if_true: files('auxbus.c'))
+system_ss.add(when: 'CONFIG_ASPEED_SOC', if_true: files(
+  'aspeed_hace.c',
+  'aspeed_i3c.c',
+  'aspeed_lpc.c',
+  'aspeed_scu.c',
+  'aspeed_sbc.c',
+  'aspeed_sdmc.c',
+  'aspeed_xdma.c',
+  'aspeed_peci.c'))
+
+system_ss.add(when: 'CONFIG_MSF2', if_true: files('msf2-sysreg.c'))
+system_ss.add(when: 'CONFIG_NRF51_SOC', if_true: files('nrf51_rng.c'))
+
+system_ss.add(when: 'CONFIG_GRLIB', if_true: files('grlib_ahb_apb_pnp.c'))
+
+system_ss.add(when: 'CONFIG_I2C', if_true: files('i2c-echo.c'))
+
+specific_ss.add(when: 'CONFIG_AVR_POWER', if_true: files('avr_power.c'))
+
+specific_ss.add(when: 'CONFIG_MAC_VIA', if_true: files('mac_via.c'))
+
+specific_ss.add(when: 'CONFIG_MIPS_CPS', if_true: files('mips_cmgcr.c', 'mips_cpc.c'))
+specific_ss.add(when: 'CONFIG_MIPS_ITU', if_true: files('mips_itu.c'))
+
+system_ss.add(when: 'CONFIG_SBSA_REF', if_true: files('sbsa_ec.c'))
+
+# HPPA devices
+system_ss.add(when: 'CONFIG_LASI', if_true: files('lasi.c'))
diff -ruN qemu-8.1.3.orig/hw/misc/meson.build.rej qemu-8.1.3/hw/misc/meson.build.rej
--- qemu-8.1.3.orig/hw/misc/meson.build.rej	1970-01-01 04:00:00.000000000 +0400
+++ qemu-8.1.3/hw/misc/meson.build.rej	2024-03-11 12:03:10.509301946 +0400
@@ -0,0 +1,12 @@
+--- hw/misc/meson.build	2023-09-22 00:19:33.000000000 +0400
++++ hw/misc/meson.build	2024-02-29 09:25:20.568683090 +0400
+@@ -35,7 +35,9 @@
+ 
+ subdir('macio')
+ 
++# ivshmem devices
+ softmmu_ss.add(when: 'CONFIG_IVSHMEM_DEVICE', if_true: files('ivshmem.c'))
++softmmu_ss.add(when: 'CONFIG_IVSHMEM_FLAT_DEVICE', if_true: files('ivshmem-flat.c'))
+ 
+ softmmu_ss.add(when: 'CONFIG_ALLWINNER_A10_CCM', if_true: files('allwinner-a10-ccm.c'))
+ softmmu_ss.add(when: 'CONFIG_ALLWINNER_A10_DRAMC', if_true: files('allwinner-a10-dramc.c'))
diff -ruN qemu-8.1.3.orig/include/hw/misc/ivshmem-flat.h qemu-8.1.3/include/hw/misc/ivshmem-flat.h
--- qemu-8.1.3.orig/include/hw/misc/ivshmem-flat.h	1970-01-01 04:00:00.000000000 +0400
+++ qemu-8.1.3/include/hw/misc/ivshmem-flat.h	2024-03-11 12:03:10.509301946 +0400
@@ -0,0 +1,85 @@
+/*
+ * Inter-VM Shared Memory Flat Device
+ *
+ * SPDX-FileCopyrightText: 2023 Linaro Ltd.
+ * SPDX-FileContributor: Gustavo Romero <gustavo.romero@linaro.org>
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ *
+ */
+
+#ifndef IVSHMEM_FLAT_H
+#define IVSHMEM_FLAT_H
+
+#include "qemu/queue.h"
+#include "qemu/event_notifier.h"
+#include "chardev/char-fe.h"
+#include "exec/memory.h"
+#include "qom/object.h"
+#include "hw/sysbus.h"
+
+#define IVSHMEM_MAX_VECTOR_NUM 64
+
+/*
+ * QEMU interface:
+ *  + QOM property "chardev" is the character device id of the ivshmem server
+ *    socket
+ *  + QOM property "shmem-size" sets the size of the RAM region shared between
+ *    the device and the ivshmem server
+ *  + sysbus MMIO region 0: device I/O mapped registers
+ *  + sysbus MMIO region 1: shared memory with ivshmem server
+ *  + sysbus IRQ 0: single output interrupt
+ */
+
+#define TYPE_IVSHMEM_FLAT "ivshmem-flat"
+typedef struct IvshmemFTState IvshmemFTState;
+
+DECLARE_INSTANCE_CHECKER(IvshmemFTState, IVSHMEM_FLAT, TYPE_IVSHMEM_FLAT)
+
+/* Ivshmem registers. See ./docs/specs/ivshmem-spec.txt for details. */
+enum ivshmem_registers {
+    INTMASK = 0,
+    INTSTATUS = 4,
+    IVPOSITION = 8,
+    DOORBELL = 12,
+};
+
+typedef struct VectorInfo {
+    EventNotifier event_notifier;
+    uint16_t id;
+} VectorInfo;
+
+typedef struct IvshmemPeer {
+    QTAILQ_ENTRY(IvshmemPeer) next;
+    VectorInfo vector[IVSHMEM_MAX_VECTOR_NUM];
+    int vector_counter;
+    uint16_t id;
+} IvshmemPeer;
+
+struct IvshmemFTState {
+    SysBusDevice parent_obj;
+
+    uint64_t msg_buf;
+    int msg_buffered_bytes;
+
+    QTAILQ_HEAD(, IvshmemPeer) peer;
+    IvshmemPeer own;
+
+    CharBackend server_chr;
+
+    /* IRQ */
+    qemu_irq irq;
+
+    /* I/O registers */
+    MemoryRegion iomem;
+    uint32_t intmask;
+    uint32_t intstatus;
+    uint32_t ivposition;
+    uint32_t doorbell;
+
+    /* Shared memory */
+    MemoryRegion shmem;
+    int shmem_fd;
+    uint32_t shmem_size;
+};
+
+#endif /* IVSHMEM_FLAT_H */
diff -ruN qemu-8.1.3.orig/ivshmem-flat.patch qemu-8.1.3/ivshmem-flat.patch
--- qemu-8.1.3.orig/ivshmem-flat.patch	1970-01-01 04:00:00.000000000 +0400
+++ qemu-8.1.3/ivshmem-flat.patch	2024-03-11 12:03:10.509301946 +0400
@@ -0,0 +1,630 @@
+diff --git a/docs/system/devices/ivshmem-flat.rst b/docs/system/devices/ivshmem-flat.rst
+new file mode 100644
+index 0000000000..1f97052804
+--- /dev/null
++++ b/docs/system/devices/ivshmem-flat.rst
+@@ -0,0 +1,33 @@
++Inter-VM Shared Memory Flat Device
++----------------------------------
++
++The ivshmem-flat device is meant to be used on machines that lack a PCI bus,
++making them unsuitable for the use of the traditional ivshmem device modeled as
++a PCI device. Machines like those with a Cortex-M MCU are good candidates to use
++the ivshmem-flat device. Also, since the flat version maps the control and
++status registers directly to the memory, it requires a quite tiny "device
++driver" to interact with other VMs, which is useful in some RTOSes, like
++Zephyr, which usually run on constrained resource targets.
++
++Similar to the ivshmem device, the ivshmem-flat device supports both peer
++notification via HW interrupts and Inter-VM shared memory. This allows the
++device to be used together with the traditional ivshmem, enabling communication
++between, for instance, an aarch64 VM  (using the traditional ivshmem device and
++running Linux), and an arm VM (using the ivshmem-flat device and running Zephyr
++instead).
++
++The ivshmem-flat device does not support the use of a ``memdev`` option (see
++ivshmem.rst for more details). It relies on the ivshmem server to create and
++distribute the proper shared memory file descriptor and the eventfd(s) to notify
++(interrupt) the peers. Therefore, to use this device, it is always necessary to
++have an ivshmem server up and running for proper device creation.
++
++Although the ivshmem-flat supports both peer notification (interrupts) and
++shared memory, the interrupt mechanism is optional. If no input IRQ is
++specified for the device it is disabled, preventing the VM from notifying or
++being notified by other VMs (a warning will be displayed to the user to inform
++the IRQ mechanism is disabled). The shared memory region is always present.
++
++The MMRs (INTRMASK, INTRSTATUS, IVPOSITION, and DOORBELL registers) offsets at
++the MMR region, and their functions, follow the ivshmem spec, so they work
++exactly as in the ivshmem PCI device (see ./specs/ivshmem-spec.txt).
+diff --git a/include/hw/misc/ivshmem-flat.h b/include/hw/misc/ivshmem-flat.h
+new file mode 100644
+index 0000000000..97ca0ddce6
+--- /dev/null
++++ b/include/hw/misc/ivshmem-flat.h
+@@ -0,0 +1,85 @@
++/*
++ * Inter-VM Shared Memory Flat Device
++ *
++ * SPDX-FileCopyrightText: 2023 Linaro Ltd.
++ * SPDX-FileContributor: Gustavo Romero <gustavo.romero@linaro.org>
++ * SPDX-License-Identifier: GPL-2.0-or-later
++ *
++ */
++
++#ifndef IVSHMEM_FLAT_H
++#define IVSHMEM_FLAT_H
++
++#include "qemu/queue.h"
++#include "qemu/event_notifier.h"
++#include "chardev/char-fe.h"
++#include "exec/memory.h"
++#include "qom/object.h"
++#include "hw/sysbus.h"
++
++#define IVSHMEM_MAX_VECTOR_NUM 64
++
++/*
++ * QEMU interface:
++ *  + QOM property "chardev" is the character device id of the ivshmem server
++ *    socket
++ *  + QOM property "shmem-size" sets the size of the RAM region shared between
++ *    the device and the ivshmem server
++ *  + sysbus MMIO region 0: device I/O mapped registers
++ *  + sysbus MMIO region 1: shared memory with ivshmem server
++ *  + sysbus IRQ 0: single output interrupt
++ */
++
++#define TYPE_IVSHMEM_FLAT "ivshmem-flat"
++typedef struct IvshmemFTState IvshmemFTState;
++
++DECLARE_INSTANCE_CHECKER(IvshmemFTState, IVSHMEM_FLAT, TYPE_IVSHMEM_FLAT)
++
++/* Ivshmem registers. See ./docs/specs/ivshmem-spec.txt for details. */
++enum ivshmem_registers {
++    INTMASK = 0,
++    INTSTATUS = 4,
++    IVPOSITION = 8,
++    DOORBELL = 12,
++};
++
++typedef struct VectorInfo {
++    EventNotifier event_notifier;
++    uint16_t id;
++} VectorInfo;
++
++typedef struct IvshmemPeer {
++    QTAILQ_ENTRY(IvshmemPeer) next;
++    VectorInfo vector[IVSHMEM_MAX_VECTOR_NUM];
++    int vector_counter;
++    uint16_t id;
++} IvshmemPeer;
++
++struct IvshmemFTState {
++    SysBusDevice parent_obj;
++
++    uint64_t msg_buf;
++    int msg_buffered_bytes;
++
++    QTAILQ_HEAD(, IvshmemPeer) peer;
++    IvshmemPeer own;
++
++    CharBackend server_chr;
++
++    /* IRQ */
++    qemu_irq irq;
++
++    /* I/O registers */
++    MemoryRegion iomem;
++    uint32_t intmask;
++    uint32_t intstatus;
++    uint32_t ivposition;
++    uint32_t doorbell;
++
++    /* Shared memory */
++    MemoryRegion shmem;
++    int shmem_fd;
++    uint32_t shmem_size;
++};
++
++#endif /* IVSHMEM_FLAT_H */
+diff --git a/hw/misc/ivshmem-flat.c b/hw/misc/ivshmem-flat.c
+new file mode 100644
+index 0000000000..998c78a5ee
+--- /dev/null
++++ b/hw/misc/ivshmem-flat.c
+@@ -0,0 +1,464 @@
++/*
++ * Inter-VM Shared Memory Flat Device
++ *
++ * SPDX-FileCopyrightText: 2023 Linaro Ltd.
++ * SPDX-FileContributor: Gustavo Romero <gustavo.romero@linaro.org>
++ * SPDX-License-Identifier: GPL-2.0-or-later
++ *
++ */
++
++#include "qemu/osdep.h"
++#include "qemu/units.h"
++#include "qemu/error-report.h"
++#include "qemu/module.h"
++#include "qapi/error.h"
++#include "hw/irq.h"
++#include "hw/qdev-properties-system.h"
++#include "hw/sysbus.h"
++#include "chardev/char-fe.h"
++#include "exec/address-spaces.h"
++#include "trace.h"
++
++#include "hw/misc/ivshmem-flat.h"
++
++static int64_t ivshmem_flat_recv_msg(IvshmemFTState *s, int *pfd)
++{
++    int64_t msg;
++    int n, ret;
++
++    n = 0;
++    do {
++        ret = qemu_chr_fe_read_all(&s->server_chr, (uint8_t *)&msg + n,
++                                   sizeof(msg) - n);
++        if (ret < 0) {
++            if (ret == -EINTR) {
++                continue;
++            }
++            exit(1);
++        }
++        n += ret;
++    } while (n < sizeof(msg));
++
++    if (pfd) {
++        *pfd = qemu_chr_fe_get_msgfd(&s->server_chr);
++    }
++    return le64_to_cpu(msg);
++}
++
++static void ivshmem_flat_irq_handler(void *opaque)
++{
++    VectorInfo *vi = opaque;
++    EventNotifier *e = &vi->event_notifier;
++    uint16_t vector_id;
++    const VectorInfo (*v)[64];
++
++    assert(e->initialized);
++
++    vector_id = vi->id;
++
++    /*
++     * The vector info struct is passed to the handler via the 'opaque' pointer.
++     * This struct pointer allows the retrieval of the vector ID and its
++     * associated event notifier. However, for triggering an interrupt using
++     * qemu_set_irq, it's necessary to also have a pointer to the device state,
++     * i.e., a pointer to the IvshmemFTState struct. Since the vector info
++     * struct is contained within the IvshmemFTState struct, its pointer can be
++     * used to obtain the pointer to IvshmemFTState through simple pointer math.
++     */
++    v = (void *)(vi - vector_id); /* v =  &IvshmemPeer->vector[0] */
++    IvshmemPeer *own_peer = container_of(v, IvshmemPeer, vector);
++    IvshmemFTState *s = container_of(own_peer, IvshmemFTState, own);
++
++    /* Clear event  */
++    if (!event_notifier_test_and_clear(e)) {
++        return;
++    }
++
++    //trace_ivshmem_flat_irq_handler(vector_id);
++
++    /*
++     * Toggle device's output line, which is connected to interrupt controller,
++     * generating an interrupt request to the CPU.
++     */
++    qemu_set_irq(s->irq, true);
++    qemu_set_irq(s->irq, false);
++}
++
++static IvshmemPeer *ivshmem_flat_find_peer(IvshmemFTState *s, uint16_t peer_id)
++{
++    IvshmemPeer *peer;
++
++    /* Own ID */
++    if (s->own.id == peer_id) {
++        return &s->own;
++    }
++
++    /* Peer ID */
++    QTAILQ_FOREACH(peer, &s->peer, next) {
++        if (peer->id == peer_id) {
++            return peer;
++        }
++    }
++
++    return NULL;
++}
++
++static IvshmemPeer *ivshmem_flat_add_peer(IvshmemFTState *s, uint16_t peer_id)
++{
++    IvshmemPeer *new_peer;
++
++    new_peer = g_malloc0(sizeof(*new_peer));
++    new_peer->id = peer_id;
++    new_peer->vector_counter = 0;
++
++    QTAILQ_INSERT_TAIL(&s->peer, new_peer, next);
++
++    //trace_ivshmem_flat_new_peer(peer_id);
++
++    return new_peer;
++}
++
++static void ivshmem_flat_remove_peer(IvshmemFTState *s, uint16_t peer_id)
++{
++    IvshmemPeer *peer;
++
++    peer = ivshmem_flat_find_peer(s, peer_id);
++    assert(peer);
++
++    QTAILQ_REMOVE(&s->peer, peer, next);
++    for (int n = 0; n < peer->vector_counter; n++) {
++        int efd;
++        efd = event_notifier_get_fd(&(peer->vector[n].event_notifier));
++        close(efd);
++    }
++
++    g_free(peer);
++}
++
++static void ivshmem_flat_add_vector(IvshmemFTState *s, IvshmemPeer *peer,
++                                    int vector_fd)
++{
++    if (peer->vector_counter >= IVSHMEM_MAX_VECTOR_NUM) {
++        //trace_ivshmem_flat_add_vector_failure(peer->vector_counter,
++        //                                      vector_fd, peer->id);
++        close(vector_fd);
++
++        return;
++    }
++
++    //trace_ivshmem_flat_add_vector_success(peer->vector_counter,
++    //                                      vector_fd, peer->id);
++
++    /*
++     * Set vector ID and its associated eventfd notifier and add them to the
++     * peer.
++     */
++    peer->vector[peer->vector_counter].id = peer->vector_counter;
++    g_unix_set_fd_nonblocking(vector_fd, true, NULL);
++    event_notifier_init_fd(&peer->vector[peer->vector_counter].event_notifier,
++                           vector_fd);
++
++    /*
++     * If it's the device's own ID, register also the handler for the eventfd
++     * so the device can be notified by the other peers.
++     */
++    if (peer == &s->own) {
++        qemu_set_fd_handler(vector_fd, ivshmem_flat_irq_handler, NULL,
++                            &peer->vector);
++    }
++
++    peer->vector_counter++;
++}
++
++static void ivshmem_flat_process_msg(IvshmemFTState *s, uint64_t msg, int fd)
++{
++    uint16_t peer_id;
++    IvshmemPeer *peer;
++
++    peer_id = msg & 0xFFFF;
++    peer = ivshmem_flat_find_peer(s, peer_id);
++
++    if (!peer) {
++        peer = ivshmem_flat_add_peer(s, peer_id);
++    }
++
++    if (fd >= 0) {
++        ivshmem_flat_add_vector(s, peer, fd);
++    } else { /* fd == -1, which is received when peers disconnect. */
++        ivshmem_flat_remove_peer(s, peer_id);
++    }
++}
++
++static int ivshmem_flat_can_receive_data(void *opaque)
++{
++    IvshmemFTState *s = opaque;
++
++    assert(s->msg_buffered_bytes < sizeof(s->msg_buf));
++    return sizeof(s->msg_buf) - s->msg_buffered_bytes;
++}
++
++static void ivshmem_flat_read_msg(void *opaque, const uint8_t *buf, int size)
++{
++    IvshmemFTState *s = opaque;
++    int fd;
++    int64_t msg;
++
++    assert(size >= 0 && s->msg_buffered_bytes + size <= sizeof(s->msg_buf));
++    memcpy((unsigned char *)&s->msg_buf + s->msg_buffered_bytes, buf, size);
++    s->msg_buffered_bytes += size;
++    if (s->msg_buffered_bytes < sizeof(s->msg_buf)) {
++        return;
++    }
++    msg = le64_to_cpu(s->msg_buf);
++    s->msg_buffered_bytes = 0;
++
++    fd = qemu_chr_fe_get_msgfd(&s->server_chr);
++
++    ivshmem_flat_process_msg(s, msg, fd);
++}
++
++static uint64_t ivshmem_flat_iomem_read(void *opaque,
++                                        hwaddr offset, unsigned size)
++{
++    IvshmemFTState *s = opaque;
++    uint32_t ret;
++
++   // trace_ivshmem_flat_read_mmr(offset);
++
++    switch (offset) {
++    case INTMASK:
++        ret = 0; /* Ignore read since all bits are reserved in rev 1. */
++        break;
++    case INTSTATUS:
++        ret = 0; /* Ignore read since all bits are reserved in rev 1. */
++        break;
++    case IVPOSITION:
++        ret = s->own.id;
++        break;
++    case DOORBELL:
++        //trace_ivshmem_flat_read_mmr_doorbell(); /* DOORBELL is write-only */
++        ret = 0;
++        break;
++    default:
++        /* Should never reach out here due to iomem map range being exact */
++        //trace_ivshmem_flat_read_write_mmr_invalid(offset);
++        ret = 0;
++    }
++
++    return ret;
++}
++
++static int ivshmem_flat_interrupt_peer(IvshmemFTState *s,
++                                       uint16_t peer_id, uint16_t vector_id)
++{
++    IvshmemPeer *peer;
++
++    peer = ivshmem_flat_find_peer(s, peer_id);
++    if (!peer) {
++        // trace_ivshmem_flat_interrupt_invalid_peer(peer_id);
++        return 1;
++    }
++
++    event_notifier_set(&(peer->vector[vector_id].event_notifier));
++
++    return 0;
++}
++
++static void ivshmem_flat_iomem_write(void *opaque, hwaddr offset,
++                                     uint64_t value, unsigned size)
++{
++    IvshmemFTState *s = opaque;
++    uint16_t peer_id = (value >> 16) & 0xFFFF;
++    uint16_t vector_id = value & 0xFFFF;
++
++    //trace_ivshmem_flat_write_mmr(offset);
++
++    switch (offset) {
++    case INTMASK:
++        break;
++    case INTSTATUS:
++        break;
++    case IVPOSITION:
++        break;
++    case DOORBELL:
++        //trace_ivshmem_flat_interrupt_peer(peer_id, vector_id);
++        ivshmem_flat_interrupt_peer(s, peer_id, vector_id);
++        break;
++    default:
++        /* Should never reach out here due to iomem map range being exact. */
++        //trace_ivshmem_flat_read_write_mmr_invalid(offset);
++        break;
++    }
++
++    return;
++}
++
++static const MemoryRegionOps ivshmem_flat_ops = {
++    .read = ivshmem_flat_iomem_read,
++    .write = ivshmem_flat_iomem_write,
++    .endianness = DEVICE_LITTLE_ENDIAN,
++    .impl = { /* Read/write aligned at 32 bits. */
++        .min_access_size = 4,
++        .max_access_size = 4,
++    },
++};
++
++static void ivshmem_flat_instance_init(Object *obj)
++{
++    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
++    IvshmemFTState *s = IVSHMEM_FLAT(obj);
++
++    /*
++     * Init mem region for 4 MMRs (ivshmem_registers),
++     * 32 bits each => 16 bytes (0x10).
++     */
++    memory_region_init_io(&s->iomem, obj, &ivshmem_flat_ops, s,
++                          "ivshmem-mmio", 0x10);
++    sysbus_init_mmio(sbd, &s->iomem);
++
++    /*
++     * Create one output IRQ that will be connect to the
++     * machine's interrupt controller.
++     */
++    sysbus_init_irq(sbd, &s->irq);
++
++    QTAILQ_INIT(&s->peer);
++}
++
++static bool ivshmem_flat_connect_server(DeviceState *dev, Error **errp)
++{
++    IvshmemFTState *s = IVSHMEM_FLAT(dev);
++    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);
++    int64_t protocol_version, msg;
++    int shmem_fd;
++    uint16_t peer_id;
++    struct stat fdstat;
++
++    /* Check ivshmem server connection. */
++    if (!qemu_chr_fe_backend_connected(&s->server_chr)) {
++        error_setg(errp, "ivshmem server socket not specified or incorret."
++                         " Can't create device.");
++        return false;
++    }
++
++    /*
++     * Message sequence from server on new connection:
++     *  _____________________________________
++     * |STEP| uint64_t msg  | int fd         |
++     *  -------------------------------------
++     *
++     *  0    PROTOCOL        -1              \
++     *  1    OWN PEER ID     -1               |-- Header/Greeting
++     *  2    -1              shmem fd        /
++     *
++     *  3    PEER IDx        Other peer's Vector 0 eventfd
++     *  4    PEER IDx        Other peer's Vector 1 eventfd
++     *  .                    .
++     *  .                    .
++     *  .                    .
++     *  N    PEER IDy        Other peer's Vector 0 eventfd
++     *  N+1  PEER IDy        Other peer's Vector 1 eventfd
++     *  .                    .
++     *  .                    .
++     *  .                    .
++     *
++     *  ivshmem_flat_recv_msg() calls return 'msg' and 'fd'.
++     *
++     *  See ./docs/specs/ivshmem-spec.txt for details on the protocol.
++     */
++
++    /* Step 0 */
++    protocol_version = ivshmem_flat_recv_msg(s, NULL);
++
++    /* Step 1 */
++    msg = ivshmem_flat_recv_msg(s, NULL);
++    peer_id = 0xFFFF & msg;
++    s->own.id = peer_id;
++    s->own.vector_counter = 0;
++
++    //trace_ivshmem_flat_proto_ver_own_id(protocol_version, s->own.id);
++
++    /* Step 2 */
++    msg = ivshmem_flat_recv_msg(s, &shmem_fd);
++    /* Map shmem fd and MMRs into memory regions. */
++    if (msg != -1 || shmem_fd < 0) {
++        error_setg(errp, "Could not receive valid shmem fd."
++                         " Can't create device!");
++        return false;
++    }
++
++    if (fstat(shmem_fd, &fdstat) != 0) {
++        error_setg(errp, "Could not determine shmem fd size."
++                         " Can't create device!");
++        return false;
++    }
++    //trace_ivshmem_flat_shmem_size(shmem_fd, fdstat.st_size);
++
++    /*
++     * Shmem size provided by the ivshmem server must be equal to
++     * device's shmem size.
++     */
++    if (fdstat.st_size != s->shmem_size) {
++        error_setg(errp, "Can't map shmem fd: shmem size different"
++                         " from device size!");
++        return false;
++    }
++
++    /*
++     * Beyond step 2 ivshmem_process_msg, called by ivshmem_flat_read_msg
++     * handler -- when data is available on the server socket -- will handle
++     * the additional messages that will be generated by the server as peers
++     * connect or disconnect.
++     */
++    qemu_chr_fe_set_handlers(&s->server_chr, ivshmem_flat_can_receive_data,
++                             ivshmem_flat_read_msg, NULL, NULL, s, NULL, true);
++
++    memory_region_init_ram_from_fd(&s->shmem, OBJECT(s),
++                                   "ivshmem-shmem", s->shmem_size,
++                                   RAM_SHARED, shmem_fd, 0, NULL);
++    sysbus_init_mmio(sbd, &s->shmem);
++
++    return true;
++}
++
++static void ivshmem_flat_realize(DeviceState *dev, Error **errp)
++{
++    if (!ivshmem_flat_connect_server(dev, errp)) {
++        return;
++    }
++}
++
++static Property ivshmem_flat_props[] = {
++    DEFINE_PROP_CHR("chardev", IvshmemFTState, server_chr),
++    DEFINE_PROP_UINT32("shmem-size", IvshmemFTState, shmem_size, 4 * MiB),
++    DEFINE_PROP_END_OF_LIST(),
++};
++
++static void ivshmem_flat_class_init(ObjectClass *klass, void *data)
++{
++    DeviceClass *dc = DEVICE_CLASS(klass);
++
++    dc->hotpluggable = true;
++    dc->realize = ivshmem_flat_realize;
++
++    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
++    device_class_set_props(dc, ivshmem_flat_props);
++
++    /* Reason: Must be wired up in code (sysbus MRs and IRQ) */
++    dc->user_creatable = true;
++}
++
++static const TypeInfo ivshmem_flat_info = {
++    .name = TYPE_IVSHMEM_FLAT,
++    .parent = TYPE_SYS_BUS_DEVICE,
++    .instance_size = sizeof(IvshmemFTState),
++    .instance_init = ivshmem_flat_instance_init,
++    .class_init = ivshmem_flat_class_init,
++};
++
++static void ivshmem_flat_register_types(void)
++{
++    type_register_static(&ivshmem_flat_info);
++}
++
++type_init(ivshmem_flat_register_types);
+diff --git a/hw/misc/Kconfig b/hw/misc/Kconfig
+index 4fc6b29b43..a643cfac3a 100644
+--- a/hw/misc/Kconfig
++++ b/hw/misc/Kconfig
+@@ -68,6 +68,11 @@ config IVSHMEM_DEVICE
+     default y if PCI_DEVICES
+     depends on PCI && LINUX && IVSHMEM && MSI_NONBROKEN
+ 
++config IVSHMEM_FLAT_DEVICE
++    bool
++    default y
++    depends on LINUX && IVSHMEM
++
+ config ECCMEMCTL
+     bool
+     select ECC
+diff --git a/hw/misc/meson.build b/hw/misc/meson.build
+index e4ef1da5a5..84dff09f5d 100644
+--- a/hw/misc/meson.build
++++ b/hw/misc/meson.build
+@@ -38,7 +38,9 @@ system_ss.add(when: 'CONFIG_SIFIVE_U_PRCI', if_true: files('sifive_u_prci.c'))
+ 
+ subdir('macio')
+ 
++# ivshmem devices
+ softmmu_ss.add(when: 'CONFIG_IVSHMEM_DEVICE', if_true: files('ivshmem.c'))
++softmmu_ss.add(when: 'CONFIG_IVSHMEM_DEVICE', if_true: files('ivshmem-flat.c'))
+ 
+ system_ss.add(when: 'CONFIG_ALLWINNER_SRAMC', if_true: files('allwinner-sramc.c'))
+ system_ss.add(when: 'CONFIG_ALLWINNER_A10_CCM', if_true: files('allwinner-a10-ccm.c'))
diff -ruN qemu-8.1.3.orig/util/mmap-alloc.c qemu-8.1.3/util/mmap-alloc.c
--- qemu-8.1.3.orig/util/mmap-alloc.c	2024-03-11 11:57:16.537516813 +0400
+++ qemu-8.1.3/util/mmap-alloc.c	2024-03-15 13:35:28.921813644 +0400
@@ -181,6 +181,7 @@
  * Activate memory in a reserved region from the given fd (if any), to make
  * it accessible.
  */
+unsigned int mmap_hugepages = 0;
 static void *mmap_activate(void *ptr, size_t size, int fd,
                            uint32_t qemu_map_flags, off_t map_offset)
 {
@@ -200,12 +201,21 @@
     flags |= fd == -1 ? MAP_ANONYMOUS : 0;
     flags |= shared ? MAP_SHARED : MAP_PRIVATE;
     flags |= noreserve ? MAP_NORESERVE : 0;
+    if (mmap_hugepages) {
+        mmap_hugepages = 0;
+        munmap(ptr, size);
+        ptr = NULL;
+        flags |= MAP_HUGETLB;
+        flags &= ~MAP_FIXED;
+    }
+    printf("flags=0x%x\n", flags);
     if (shared && sync) {
         map_sync_flags = MAP_SYNC | MAP_SHARED_VALIDATE;
     }
 
     activated_ptr = mmap(ptr, size, prot, flags | map_sync_flags, fd,
                          map_offset);
+    printf("activated_ptr1=0x%p\n", activated_ptr);
     if (activated_ptr == MAP_FAILED && map_sync_flags) {
         if (errno == ENOTSUP) {
             char *proc_link = g_strdup_printf("/proc/self/fd/%d", fd);
@@ -229,7 +239,9 @@
          * If mmap failed with MAP_SHARED_VALIDATE | MAP_SYNC, we will try
          * again without these flags to handle backwards compatibility.
          */
+        flags &= ~MAP_HUGETLB;
         activated_ptr = mmap(ptr, size, prot, flags, fd, map_offset);
+        printf("activated_ptr1=0x%p\n", activated_ptr);
     }
     return activated_ptr;
 }
diff -ruN qemu-8.1.3.orig/.vscode/settings.json qemu-8.1.3/.vscode/settings.json
--- qemu-8.1.3.orig/.vscode/settings.json	1970-01-01 04:00:00.000000000 +0400
+++ qemu-8.1.3/.vscode/settings.json	2024-03-13 11:20:56.670137001 +0400
@@ -0,0 +1,5 @@
+{
+    "files.associations": {
+        "*.code": "c"
+    }
+}
\ No newline at end of file
